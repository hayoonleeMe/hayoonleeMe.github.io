---
title: "C++ Algorithm Chapter3_4 ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜ Dijkstra Algorithm"
excerpt: ""
categories:
  - Cpp Algorithm
tags:
  - Cpp
last_modified_at: 2021-10-06
toc: true
toc_sticky: true
toc_label: "ëª©ì°¨ğŸ‘€"
---

<pre>ë³¸ í•„ê¸°ëŠ” ì¸í”„ëŸ°ì˜ Rookiss ë‹˜ì˜ ê°•ì˜ì¸ <b>[C++ê³¼ ì–¸ë¦¬ì–¼ë¡œ ë§Œë“œëŠ” MMORPG ê²Œì„ ê°œë°œ ì‹œë¦¬ì¦ˆ] Part3: ìë£Œêµ¬ì¡°ì™€ ì•Œê³ ë¦¬ì¦˜</b> ë¥¼ ë“£ê³  ì‘ì„±í•©ë‹ˆë‹¤.</pre>{: .notice--success}

### [ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜]
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <stack>
#include <queue>
using namespace std;

struct Vertex
{
    // int data;
};

vector<Vertex> vertices;
vector<vector<int>> adjacent;	// ì¸ì ‘ í–‰ë ¬

vector<int> _path;
int dest = 4;

void CreateGraph()
{
    vertices.resize(6);
    adjacent = vector<vector<int>>(6, vector<int>(6, -1));

    adjacent[0][1] = 15;
    adjacent[1][0] = 15;

    adjacent[0][3] = 35;
    adjacent[3][0] = 35;

    adjacent[1][2] = 5;
    adjacent[2][1] = 5;

    adjacent[1][3] = 10;
    adjacent[3][1] = 10;

    adjacent[3][4] = 5;
    adjacent[4][3] = 5;

    adjacent[5][4] = 5;
    adjacent[4][5] = 5;
}

void Dijkstra(int here)
{
    struct VertexCost
    {
        int vertex;
        int cost;
    };

    list<VertexCost> discovered;	// ë°œê²¬ ëª©ë¡  
    vector<int> best(6, INT32_MAX);	// ê° ì •ì ë³„ë¡œ ì§€ê¸ˆê¹Œì§€ ë°œê²¬í•œ ìµœì†Œ ê±°ë¦¬ 
    vector<int> parent(6, -1);

    discovered.push_back(VertexCost{ here, 0 });
    best[here] = 0;
    parent[here] = here;

    while (discovered.empty() == false)
    {
        if (best[dest] != INT32_MAX)
            break;

        // ë°œê²¬í•œ í›„ë³´ ì¤‘ ì œì¼ ì¢‹ì€ í›„ë³´(cost ê°€ ê°€ì¥ ì‘ì€)ë¥¼ ì°¾ëŠ”ë‹¤.
        list<VertexCost>::iterator bestIt;
        int bestCost = INT32_MAX;

        for (auto it = discovered.begin(); it != discovered.end(); it++)	// ìš°ì„ ìˆœìœ„ í priority_queue ë¡œ ë°˜ë³µì„ ìƒëµ.
        {
            const int cost = it->cost;

            if (cost < bestCost)
            {
                bestCost = cost;
                bestIt = it;
            }
        }

        int cost = bestIt->cost;
        here = bestIt->vertex;
        discovered.erase(bestIt);

        // ë°©ë¬¸? ë” ì§§ì€ ê²½ë¡œë¥¼ ë’¤ëŠ¦ê²Œ ì°¾ì•˜ë‹¤ë©´ ìŠ¤í‚µ.
        if (best[here] < cost)
            continue;

        // ë°©ë¬¸
        for (int there = 0; there < 6; there++)
        {
            // ì—°ê²°ë˜ì§€ ì•Šì•˜ìœ¼ë©´ ìŠ¤í‚µ.
            if (adjacent[here][there] == -1)
                continue;

            int nextCost = best[here] + adjacent[here][there];

            // ë” ì¢‹ì€ ê²½ë¡œë¥¼ ê³¼ê±°ì— ì°¾ì•˜ìœ¼ë©´ ìŠ¤í‚µ.
            if (nextCost >= best[there])
                continue;

            discovered.push_back(VertexCost{ there, nextCost });
            best[there] = nextCost;
            parent[there] = here;
        }
    }

    _path.clear();

    int pos = dest;

    while (true)
    {
        _path.push_back(pos);

        if (pos == parent[pos])
            break;

        pos = parent[pos];
    }

    std::reverse(_path.begin(), _path.end());

    for (int i = 0; i < _path.size(); i++)
    {
        cout << _path[i] << " ";
    }
    cout << endl;
}


int main()
{
    CreateGraph();

    Dijikstra(0);
}
```

<pre>ë³¸ ë¸”ë¡œê·¸ëŠ” ê°œì¸ ê³µë¶€ ê¸°ë¡ì˜ ëª©ì ì„ ê°€ì§‘ë‹ˆë‹¤. í¬ìŠ¤íŠ¸ì˜ ë‚´ìš©ì€ ì–¸ì œë“ ì§€ ë°”ë€” ìˆ˜ ìˆìŠµë‹ˆë‹¤.</pre>{: .notice--info}