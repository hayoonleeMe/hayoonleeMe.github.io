---
title: "C++ Algorithm Chapter4_3 ìš°ì„ ìˆœìœ„ í êµ¬í˜„ ì—°ìŠµ"
excerpt: ""
categories:
  - Cpp Algorithm
tags:
  - Cpp
last_modified_at: 2021-10-11
toc: true
toc_sticky: true
toc_label: "ëª©ì°¨ğŸ‘€"
---

<pre>ë³¸ í•„ê¸°ëŠ” ì¸í”„ëŸ°ì˜ Rookiss ë‹˜ì˜ ê°•ì˜ì¸ <b>[C++ê³¼ ì–¸ë¦¬ì–¼ë¡œ ë§Œë“œëŠ” MMORPG ê²Œì„ ê°œë°œ ì‹œë¦¬ì¦ˆ] Part3: ìë£Œêµ¬ì¡°ì™€ ì•Œê³ ë¦¬ì¦˜</b> ë¥¼ ë“£ê³  ì‘ì„±í•©ë‹ˆë‹¤.</pre>{: .notice--success}

### [ìš°ì„ ìˆœìœ„ í êµ¬í˜„ ì—°ìŠµ]
```cpp
#include <iostream>
#include <vector>
#include <list>
#include <stack>
#include <queue>
using namespace std;

template<typename T>
class PriorityQueueMySelf       // í˜¼ì êµ¬í˜„í•´ë³¸ ì½”ë“œ
{
public:
    PriorityQueueMySelf()
    {
        _size = 0;
    }

    void push(const T& data)
    {
        _list.push_back(data);
        _size++;
        
        if (_size == 1) return;

        int last = _size - 1;
        int parent = -1;

        while (last != 0)
        {
            if (last % 2 == 0)	// ë§ˆì§€ë§‰ ì›ì†Œê°€ ì˜¤ë¥¸ìª½ ìì‹
            {
                parent = (last - 1) / 2;
                int left = 2 * parent + 1;
                int change = -1;
                if (_list[left] > _list[parent])
                    change = left;
                else
                    change = last;

                if (_list[change] > _list[parent])
                {
                    T temp = _list[parent];
                    _list[parent] = _list[change];
                    _list[change] = temp;
                }
            }
            else                // ë§ˆì§€ë§‰ ì›ì†Œê°€ ì™¼ìª½ ìì‹
            {
                parent = (last - 1) / 2;
                if (_list[last] > _list[parent])
                {
                    T temp = _list[parent];
                    _list[parent] = _list[last];
                    _list[last] = temp;
                }
            }
            last = parent;
        }
    }

    bool empty()
    {
        return _size == 0;
    }

    T& top()
    {
        return _list[0];
    }

    int size()
    {
        return _size;
    }

    void pop()
    {
        if (_size == 0) return;

        int last = _size - 1;

        _list[0] = _list[last];
        _list[last] = -1;
        _size--;
        last--;

        if (_size <= 1) return;

        int parent = 0;

        while (parent != last)
        {
            int left = 2 * parent + 1;
            int right = 2 * parent + 2;
            int change = -1;

            if (right < _size)  // ì˜¤ë¥¸ìª½ ìì‹ì´ ìˆë‹¤ë©´
            {
                if (_list[right] > _list[left])
                    change = right;
                else
                    change = left;
            }
            else if (left < _size)
            {
                change = left;  // ì˜¤ë¥¸ìª½ ìì‹ì´ ì—†ê³  ì™¼ìª½ ìì‹ì´ ìˆë‹¤ë©´
            }
            else                // ìì‹ì´ ì—†ë‹¤ë©´
                break;

            if (_list[change] > _list[parent])
            {
                T temp = _list[change];
                _list[change] = _list[parent];
                _list[parent] = temp;
            }
            else
                break;

            parent = change;
        }
    }

private:
    vector<T>	_list;
    int	        _size;
};

template<typename T, typename Container = vector<T>, typename Predicate = less<T>>
class PriorityQueue             // ê°•ì˜ ì½”ë“œ
{
public:
    void push(const T& data)
    {
        // ìš°ì„  í™ êµ¬ì¡°ë¶€í„° ë§ì¶°ì¤€ë‹¤.
        _heap.push_back(data);

        // ë„ì¥ê¹¨ê¸° ì‹œì‘
        int now = static_cast<int>(_heap.size()) - 1;
        // ë£¨íŠ¸ë…¸ë“œê¹Œì§€
        while (now > 0)
        {
            // ë¶€ëª¨ ë…¸ë“œì™€ ë¹„êµí•´ì„œ ë” ì‘ìœ¼ë©´ íŒ¨ë°°
            int next = (now - 1) / 2;
            /*if (_heap[now] < _heap[next])
                break;*/

            if (_predicate(_heap[now], _heap[next]))	// í•˜ë“œì½”ë”© ëŒ€ì‹  Predicate ì‚¬ìš©
                break;

            // ë°ì´í„° êµì²´
            ::swap(_heap[now], _heap[next]);
            now = next;
        }
    }

    void pop()
    {
        _heap[0] = _heap.back();
        _heap.pop_back();

        int now = 0;

        while (true)
        {
            int left = 2 * now + 1;
            int right = 2 * now + 2;

            // ë¦¬í”„ì— ë„ë‹¬í•œ ê²½ìš°
            if (left >= _heap.size())
                break;

            int next = now;

            // ì™¼ìª½ê³¼ ë¹„êµ
            if (_predicate(_heap[next], _heap[left]))
                next = left;

            // ë‘˜ ì¤‘ ìŠ¹ìë¥¼ ì˜¤ë¥¸ìª½ê³¼ ë¹„êµ
            if (right < _heap.size() && _predicate(_heap[next], _heap[right]))
                next = right;

            // ì™¼ìª½/ì˜¤ë¥¸ìª½ ë‘˜ ë‹¤ í˜„ì¬ ê°’ë³´ë‹¤ ì‘ìœ¼ë©´ ì¢…ë£Œ
            if (next == now)
                break;

            ::swap(_heap[now], _heap[next]);
            now = next;
        }
    }

    T& top()
    {
        return _heap[0];
    }

    bool empty()
    {
        return _heap.empty();
    }

private:
    Container _heap = {};
    Predicate _predicate = {};
};

int main()
{
    PriorityQueue<int, vector<int>, greater<int>> pq;	
    //priority_queue<int, vector<int>, greater<int>> pq;	// min heap ìœ¼ë¡œ ë³€ê²½

    pq.push(100);
    pq.push(300);
    pq.push(200);
    pq.push(500);
    pq.push(400);

    while (pq.empty() == false)
    {
        int value = pq.top();
        pq.pop();

        cout << value << endl;
    }
}

// push , pop ì˜ ì‹œê°„ë³µì¡ë„ëŠ” O(logn) ì´ë‹¤.
```
<pre>ë³¸ ë¸”ë¡œê·¸ëŠ” ê°œì¸ ê³µë¶€ ê¸°ë¡ì˜ ëª©ì ì„ ê°€ì§‘ë‹ˆë‹¤. í¬ìŠ¤íŠ¸ì˜ ë‚´ìš©ì€ ì–¸ì œë“ ì§€ ë°”ë€” ìˆ˜ ìˆìŠµë‹ˆë‹¤.</pre>{: .notice--info}