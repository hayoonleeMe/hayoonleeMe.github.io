---
title: "C++ Games Chapter3_3 ì§ˆëŸ‰(ì§ˆì )-ìŠ¤í”„ë§ ì‹œìŠ¤í…œ Mass-Spring System"
excerpt: "ì§ˆëŸ‰-ìŠ¤í”„ë§ ì‹œìŠ¤í…œ Mass-Spring System"
categories:
  - Cpp MakeGames
tags:
  - Cpp
last_modified_at: 2021-08-22
toc: true
toc_sticky: true
toc_label: "ëª©ì°¨ğŸ‘€"
---

<pre>ë³¸ í•„ê¸°ëŠ” ì¸í”„ëŸ°ì˜ í™ì •ëª¨ êµìˆ˜ë‹˜ì˜ ê°•ì˜ì¸ <b>í™ì •ëª¨ì˜ ê²Œì„ ë§Œë“¤ê¸° ì—°ìŠµ ë¬¸ì œ íŒ¨í‚¤ì§€</b> ë¥¼ ë“£ê³  ì‘ì„±í•©ë‹ˆë‹¤.</pre>{: .notice--success}

### ì§ˆëŸ‰(ì§ˆì )-ìŠ¤í”„ë§ ì‹œìŠ¤í…œ Mass-Spring System
ëª¨ì–‘ì´ ë³€í•˜ëŠ” ë¬¼ì²´ë¥¼ ì‹œë®¬ë ˆì´ì…˜í•  ë•Œ ë§ì´ ì‚¬ìš©í•˜ëŠ” Mass-Spring System ì— ëŒ€í•´ì„œ ì•Œì•„ë³¸ë‹¤.

#### Mass-Spring System
`3_3_1.png ì‚¬ì§„ ì¶”ê°€`
Mass-Spring System ì€ ì§ˆëŸ‰ì´ ëª¨ì—¬ìˆëŠ” ì§ˆì (íŒŒë€ì›) ê³¼ ê¸¸ì´ê°€ ë³€í•  ìˆ˜ ìˆëŠ” ìŠ¤í”„ë§ì˜ ì¡°í•©ìœ¼ë¡œ ì´ë£¨ì–´ì§„ë‹¤.    
í•œ ì‹œìŠ¤í…œ ì•ˆì—ëŠ” ìŠ¤í”„ë§ê³¼ ì§ˆã…ˆë¨¸ì´ ì—¬ëŸ¬ê°œê°€ ë“¤ì–´ê°ˆ ìˆ˜ ìˆë‹¤.    
ì´ë•Œ ì§ˆëŸ‰ Mass ëŠ” m ìœ¼ë¡œ í‘œê¸°í•˜ê³  ìŠ¤í”„ë§ì˜ ë”±ë”±í•œ ì •ë„ì¸ ê°•ë„ëŠ” k ë¡œ í‘œì‹œí•œë‹¤.    

`3_3_2.png ì‚¬ì§„ ì¶”ê°€`
Spring force f ë¥¼ êµ¬í•˜ë©´ f ë¥¼ m ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ê°€ì†ë„ a ë¥¼ êµ¬í•˜ê³  v ì™€ x ë¥¼ ì—…ë°ì´íŠ¸ í•  ìˆ˜ ìˆë‹¤.    

#### Hooke`s Law in 1D
`3_3_3.png ì‚¬ì§„ ì¶”ê°€`
ìš©ìˆ˜ì² ì˜ í˜ì„ ê³„ì‚°í•˜ëŠ” ë²•ì¹™ì„ Hooke`s Law ë¼ í•˜ëŠ”ë° 1ì°¨ì›ì—ì„œëŠ” í˜•íƒœê°€ ê½¤ ê°„ë‹¨í•˜ë‹¤.    
ìš©ìˆ˜ì² ì€ ì›ë˜ ë§Œë“¤ì–´ì§ˆ ë•Œ ì •í•´ì§„ ê¸¸ì´ê°€ ìˆê³  ê·¸ ê¸¸ì´ë³´ë‹¤ ëŠ˜ì–´ë‚˜ë©´ ì›ë˜ ê¸¸ì´ë¡œ ëŒì•„ê°€ê¸° ìœ„í•´ì„œ ë‹¹ê¸°ëŠ” í˜ì´ ì‘ìš©í•  ê²ƒì´ê³  ìš©ìˆ˜ì² ì„ ê½‰ ëˆ„ë¥´ë©´ ì›ë˜ì˜ ê¸¸ì´ë¡œ ëŒì•„ê°€ê¸° ìœ„í•´ì„œ íŒ½ì°½í•˜ëŠ” í˜ì„ ë°œìƒì‹œí‚¬ ê²ƒì´ë‹¤.    
ì›ë˜ì˜ ê¸¸ì´ê°€ l0 ê³  í˜„ì¬ì˜ ê¸¸ì´ê°€ l ì´ë¼ë©´ ì‚¬ì§„ì—ì„œëŠ” ìŠ¤í”„ë§ì˜ ê¸¸ì´ê°€ l ì—ì„œ l0 ë¡œ ì¤„ì–´ë“¤ê¸° ìœ„í•´ì„œ ì§ˆì ì„ ì•ˆìª½ìœ¼ë¡œ ë‹¹ê¸°ëŠ” í˜ì´ ë°œìƒí•  ê²ƒì´ë‹¤.    
ë°˜ëŒ€ë¡œ l ì—ì„œ l0 ë³´ë‹¤ ì§ˆì ì´ ì•ˆìœ¼ë¡œ ë“¤ì–´ê°€ ìˆë‹¤ë©´ ìŠ¤í”„ë§ì´ ì§ˆì ì„ ë°”ê¹¥ìœ¼ë¡œ ë°€ì–´ë‚´ë ¤ê³  í•  ê²ƒì´ë‹¤.    
ê²°ê³¼ì ìœ¼ë¡œ Spring force f ëŠ” l ê³¼ l0 ì˜ ì°¨ì´ì— ë¹„ë¡€í•˜ëŠ” í˜ì´ ë°œìƒí•  ê²ƒì´ê³  ì‹ì—ì„œ -ê°€ ë¶™ì–´ìˆëŠ” ì´ìœ ëŠ” ë³µì›ë ¥(ì›ë˜ ê¸¸ì´ë¡œ ëŒì•„ê°€ë ¤ëŠ” í˜)ì„ í‘œê¸°í•´ì¤€ ê²ƒì´ë‹¤.    

#### Hooke`s Law    
`3_3_4.png ì‚¬ì§„ ì¶”ê°€`
1ì°¨ì› ì™¸ì˜ 2ì°¨ì›ì´ë‚˜ 3ì°¨ì›ì— ëŒ€í•´ì„œ í’€ê¸° ìœ„í•´ì„œëŠ” ë°©í–¥ì´ í•„ìš”í•˜ë‹¤.    
ìœ„ì˜ ì‚¬ì§„ì²˜ëŸ¼ i ë²ˆì§¸ì™€ j ë²ˆì§¸ ì§ˆì ì´ ì¡´ì¬í•œë‹¤ê³  í•  ë•Œ ì§ˆì  ì‚¬ì´ì˜ ê±°ë¦¬ê°€ ê¸¸ì–´ì§€ê±°ë‚˜ ì§§ì•„ì§ˆ ë•Œ ìŠ¤í”„ë§ì´ ì›ë˜ ê¸¸ì´ë¡œ ëŒì•„ê°€ê¸° ìœ„í•´ì„œ í˜ì„ ë°œìƒì‹œí‚¬ ê²ƒì´ë‹¤.    
xi - xj ê°€ ë‘ ì§ˆì ì‚¬ì´ì˜ í˜„ì¬ ê±°ë¦¬ê°€ ë  ê²ƒì´ê³  ê±°ê¸°ì„œ ì›ë˜ì˜ ê¸¸ì´ì¸ l0 ë¥¼ ë¹¼ì¤€ë‹¤. (l0 ëŠ” Mass-Spring System ì„ ì´ˆê¸°í™”í•  ë•Œ ê²°ì •í•  ìˆ˜ ìˆëŠ” ìš”ì†Œì´ë‹¤.)    
ìŠ¤í”„ë§ì´ í˜ì„ ì „ë‹¬í•  ë•ŒëŠ” xi ì™€ xj ë¥¼ ì—°ê²°í•˜ëŠ” ì„  ìƒì—ì„œë§Œ ì‘ìš©í•  ê²ƒì´ë‹¤.    
ë”°ë¼ì„œ ë°©í–¥ì„ í‘œê¸°í•˜ê¸° ìœ„í•´ì„œ ë°©í–¥ë²¡í„° xi - xj/|xi - xj| ë¥¼ ê³±í•´ì¤€ë‹¤.    
xi ì— ì‘ìš©í•˜ëŠ” í˜ f-ij,spring ì€ xj ì— ì‘ìš©í•˜ëŠ” í˜ f-ji,spring ì˜ ë°˜ëŒ€ê°€ ë  ê²ƒì´ë‹¤.    

#### ì½”ë“œë¡œ Mass-Spring System êµ¬í˜„í•˜ê¸°
```cpp
void update() override
{
    const float dt = getTimeStep() * 0.4f;
    const float epsilon = 0.5f;

    // physics update (Temporarily disabled)
    //rb0.update(dt);
    //rb1.update(dt);

    // coefficients
    const vec2 gravity(0.0f, -9.8f);
    const float l0 = 0.5f;
    const float coeff_k = 100.0f;
    const float coeff_d = 100.0f;

    // update rb1 (Note: rb0 is fixed)
    {
        /*const auto distance = (rb1.pos - rb0.pos).getMagnitude();
        const auto direction = (rb1.pos - rb0.pos) / distance;*/

        // compute stiffness force
        // compute damping force

        const auto accel = gravity;

        rb1.vel += accel * dt;
        rb1.pos += rb1.vel * dt;
    }

    // draw
    drawWall();

    // spring
    drawLine(Colors::red, rb0.pos, Colors::red, rb1.pos);

    // mass points
    rb0.draw();
    rb1.draw();

    // reset button
    if (isKeyPressedAndReleased(GLFW_KEY_R)) reset();
}
```
rb0 ì€ ê³ ì •ë˜ì–´ìˆê³  rb1 ë§Œ ì›€ì§ì´ëŠ” ìƒí™©ì´ë‹¤.    
í˜„ì¬ì˜ ì´ˆê¸° ì½”ë“œëŠ” rb0 ê³¼ rb1 ì˜ update ì˜ í˜¸ì¶œì„ ë§‰ê³  ìˆê¸° ë•Œë¬¸ì— ë²½, ë°”ë‹¥ê³¼ ì¶©ëŒì‹œ íŠ•ê²¨ë‚˜ê°€ëŠ” ê¸°ëŠ¥ì€ ì œí•œë˜ì–´ìˆë‹¤.    
ì›€ì§ì¼ ìˆ˜ ìˆëŠ” rb1 ì˜ update í•¨ìˆ˜ë§Œ í•´ë‹¹ í•¨ìˆ˜ì—ì„œ êµ¬í˜„í•˜ëŠ” ìƒí™©ì¸ë°, í˜„ì¬ëŠ” ë‹¨ìˆœ ììœ ë‚™í•˜í•˜ëŠ” ê¸°ëŠ¥ë§Œì„ ê°€ì§„ë‹¤.    

ì—¬ê¸°ì— Spring force ë¥¼ êµ¬í˜„í•´ì„œ ìŠ¤í”„ë§ì´ rb1 ë¬¼ì²´ë¥¼ ë‹¹ê²¨ ì˜¬ë¦¬ë„ë¡ êµ¬í˜„í•  ê²ƒì´ë‹¤.

```cpp
void update() override
{
    const float dt = getTimeStep() * 0.4f;
    const float epsilon = 0.5f;

    // physics update (Temporarily disabled)
    //rb0.update(dt);
    //rb1.update(dt);

    // coefficients	: ê³„ìˆ˜
    const vec2 gravity(0.0f, -9.8f);
    const float l0 = 0.5f;
    const float coeff_k = 50.0f;	// stiffness K
    const float coeff_d = 100.0f;	// 

    // update rb1 (Note: rb0 is fixed)
    {
        const auto distance = (rb1.pos - rb0.pos).getMagnitude();
        const auto direction = (rb1.pos - rb0.pos) / distance;		// unit vector

        // compute stiffness force
        const auto spring_force = direction * -(distance - l0) * coeff_k;

        // compute damping force

        const auto accel = gravity + spring_force / rb1.mass;

        rb1.vel += accel * dt;
        rb1.pos += rb1.vel * dt;
    }
    ...
}
```
spring_force ë¥¼ êµ¬í•œ ê²ƒì— ì§ˆëŸ‰ì„ ë‚˜ëˆ  ê°€ì†ë„ë¥¼ êµ¬í•´ ê°€ì†ë„ accel ì— ë”í•´ì¤€ë‹¤.    
coeff_k ëŠ” spring_force ë¥¼ êµ¬í•˜ëŠ” ì‹ì˜ stiffness ë¥¼ ë‚˜íƒ€ë‚´ëŠ” K ì¸ë° ì‘ì„ìˆ˜ë¡ ìŠ¤í”„ë§ì˜ í˜ì´ ì•½í•œ ê²ƒì´ë¯€ë¡œ ìŠ¤í”„ë§ì´ ë§ì´ ì¶œë ê±°ë¦¬ê³  ë°˜ëŒ€ë¡œ ì»¤ì§ˆìˆ˜ë¡ ìŠ¤í”„ë§ì˜ í˜ì´ ê°•í•œ ê²ƒì´ë¯€ë¡œ ëœ ì¶œë ê±°ë¦°ë‹¤.    

#### Damping Force in 1D
`3_3_5.png ì‚¬ì§„ ì¶”ê°€`
ë¬´ê±°ìš´ ë¬¸ì´ ìˆëŠ” ê³³ì— ë¬¸ì´ ë„ˆë¬´ ë¹¨ë¦¬ ì—´ë¦¬ê±°ë‚˜ ë‹«íˆì§€ ì•Šë„ë¡ ë¬¸ ìœ„ìª½ì— ì»¤ë‹¤ë€ ì¥ì¹˜ë¥¼ Damper ë¼ ë¶€ë¥¸ë‹¤.     
Spring Force ëŠ” ê¸¸ì´ì˜ ì°¨ì´ì— ë¹„ë¡€í•´ì„œ ì‘ìš©í•˜ëŠ”ë° ë¹„í•´ Damping Force ëŠ” ì†ë„ì˜ ì°¨ì´ì— ë¹„ë¡€í•˜ì—¬ ì‘ìš©í•œë‹¤.    

ìœ„ì˜ ì‚¬ì§„ì—ì„œ ì§ˆì ì˜ ì†ë„ê°€ 0ì´ ì•„ë‹ˆë¼ë©´ Damper ëŠ” ì§ˆì ì˜ ì†ë„ë¥¼ 0ìœ¼ë¡œ ë§Œë“¤ë ¤ê³  í•  ê²ƒì´ë‹¤.    
ë§Œì•½ ì™¼ìª½ì´ ê³ ì •ëœ ë²½ì´ ì•„ë‹ˆë¼ ì›€ì§ì´ëŠ” ë¬¼ì²´ë¼ë©´ ë‘ ë¬¼ì²´ì˜ ì†ë„ê°€ ë¹„ìŠ·í•´ì§€ë„ë¡ í˜ì´ ë°œìƒí•  ê²ƒì´ë‹¤.

`3_3_6.png ì‚¬ì§„ ì¶”ê°€`
2ì°¨ì›ì—ì„œëŠ” Damping Force ê°€ ì‘ìš©í•˜ëŠ” ë°©í–¥ì´ ë‘ ì§ˆì ì„ ì—°ê²°í•˜ëŠ” ì„  ìœ„ì—ì„œë§Œ ì‘ìš©í•  ìˆ˜ ìˆê¸° ë•Œë¬¸ì— ì‹ì— ì¶”ê°€ì ìœ¼ë¡œ ë°©í–¥ì„ ê²°ì •í•˜ëŠ” í•­ë“¤ì´ ë¶™ì–´ìˆë‹¤.    
ë‘ ì§ˆì ì˜ ì†ë„ì°¨ì´ëŠ” ë²¡í„°ì´ê³  xi-xj / |xi-xj| ëŠ” ë°©í–¥ì„ ì˜ë¯¸í•˜ëŠ” ë²¡í„°ì¼ ê²ƒì´ë¯€ë¡œ ë‘ê°œë¥¼ dot product í•˜ë©´ ì†ë„ì°¨ì´ ë²¡í„° ì¤‘ì—ì„œ í•´ë‹¹ ë°©í–¥ìš”ì†Œë§Œì„ ê°€ì ¸ì˜¤ëŠ” ê²ƒì´ë‹¤.    

```cpp
void update() override
{
    const float dt = getTimeStep() * 0.4f;
    const float epsilon = 0.5f;

    // physics update (Temporarily disabled)
    //rb0.update(dt);
    //rb1.update(dt);

    // coefficients	: ê³„ìˆ˜
    const vec2 gravity(0.0f, -9.8f);
    const float l0 = 0.5f;
    const float coeff_k = 50.0f;	// stiffness K
    const float coeff_d = 100.0f;	// 

    // update rb1 (Note: rb0 is fixed)
    {
        const auto distance = (rb1.pos - rb0.pos).getMagnitude();
        const auto direction = (rb1.pos - rb0.pos) / distance;		// unit vector

        // compute stiffness force
        const auto spring_force = direction * -(distance - l0) * coeff_k + 
            direction * -(rb1.vel - rb0.vel).getDotProduct(direction) * coeff_d;

        // compute damping force

        const auto accel = gravity + spring_force / rb1.mass;

        rb1.vel += accel * dt;
        rb1.pos += rb1.vel * dt;
    }
    ...
}
```
Damping Force ë¥¼ spring_force ì— ë”í•´ì£¼ì–´ êµ¬í˜„í•œë‹¤.     
spring_force ë§Œ ì¡´ì¬í•˜ë˜ ë•Œì™€ëŠ” ë‹¬ë¦¬ ì¶œë ì„ì´ í¬ê²Œ ì¤„ì–´ë“¤ì–´ ê³ ì •ëœ ìŠ¤í”„ë§ì„ ê°€ì§€ëŠ” ê²ƒì²˜ëŸ¼ ë³´ì´ê²Œ ëœë‹¤.    
coeff_d ê°€ ì¤„ì–´ë“¤ìˆ˜ë¡ ì¶œë ì„ì´ í¬ê²Œ ë³´ì´ê²Œ ëœë‹¤.    


### ë„ì „ë¬¸ì œ1
`3_3_7.png ì‚¬ì§„ ì¶”ê°€`
Mass ì™€ Spring ì„ í•˜ë‚˜ ë” ì¶”ê°€í•˜ì—¬ êµ¬í˜„í•œë‹¤.

```cpp
class Example : public Game2D	// Mass-Spring System Excercise 1
{
public:
    RigidCircle rb0, rb1, rb2;	// rb0 ì€ ê³ ì •, rb1 ê³¼ rb2 ê°€ ì›€ì§ì¸ë‹¤

    Example()
        : Game2D()
    {
        reset();
    }

    void reset()
    {
        // Initial position and velocity
        rb0.pos = vec2(0.0f, 0.5f);
        rb0.vel = vec2(0.0f, 0.0f);
        rb0.color = Colors::yellow;
        rb0.radius = 0.03f;
        rb0.mass = 1.0f;

        rb1.pos = vec2(0.5f, 0.1f);
        rb1.vel = vec2(0.0f, 0.0f);
        rb1.color = Colors::blue;
        rb1.radius = 0.03f;
        rb1.mass = rb0.mass * std::pow(rb1.radius / rb0.radius, 2.0f);

        rb2.pos = vec2(0.25f, -0.4f);
        rb2.vel = vec2(0.0f, 0.0f);
        rb2.color = Colors::skyblue;
        rb2.radius = 0.03f;
        rb2.mass = rb0.mass * std::pow(rb2.radius / rb0.radius, 2.0f);
    }

    void drawWall()
    {
        setLineWidth(5.0f);
        drawLine(Colors::blue, { -1.0f, -1.0f }, Colors::blue, { 1.0f, -1.0f });
        drawLine(Colors::blue, { 1.0f, -1.0f }, Colors::blue, { 1.0f, 1.0f });
        drawLine(Colors::blue, { -1.0f, -1.0f }, Colors::blue, { -1.0f, 1.0f });
    }

    void update() override
    {
        const float dt = getTimeStep() * 0.4f;
        const float epsilon = 0.5f;

        // physics update (Temporarily disabled)
        //rb0.update(dt);
        //rb1.update(dt);

        // coefficients	: ê³„ìˆ˜
        const vec2 gravity(0.0f, -9.8f);
        const float l0 = 0.5f;
        const float coeff_k = 70.0f;	// stiffness K
        const float coeff_d = 10.0f;	// 

        // update rb1, rb2 (Note: rb0 is fixed)
        {
            const auto distance_1To0 = (rb1.pos - rb0.pos).getMagnitude();
            const auto distance_1To2 = (rb1.pos - rb2.pos).getMagnitude();
            const auto direction_1To0 = (rb1.pos - rb0.pos) / distance_1To0;
            const auto direction_1To2 = (rb1.pos - rb2.pos) / distance_1To2;

            // compute stiffness force
            const auto spring_force_1To0 = direction_1To0  * -coeff_k * (distance_1To0 - l0);
            const auto spring_force_1To2 = direction_1To2  * -coeff_k * (distance_1To2 - l0);
            const auto spring_force_2To1 = -spring_force_1To2;

            // compute damping force
            const auto damping_force_1To0 = direction_1To0 * -coeff_d * 
            (rb1.pos - rb0.pos).getDotProduct(direction_1To0);
            const auto damping_force_1To2 = direction_1To2 * -coeff_d * 
            (rb1.pos - rb2.pos).getDotProduct(direction_1To2);
            const auto damping_force_2To1 = -damping_force_1To2;

            const auto accel_rb1 = gravity + (spring_force_1To0 + spring_force_1To2 + 
            damping_force_1To0 + damping_force_1To2) / rb1.mass;
            const auto accel_rb2 = gravity + (spring_force_2To1 + damping_force_2To1) / rb2.mass;

            rb1.vel += accel_rb1 * dt;
            rb1.pos += rb1.vel * dt;
            rb2.vel += accel_rb2 * dt;
            rb2.pos += rb2.vel * dt;
        }

        // draw
        drawWall();

        // spring
        drawLine(Colors::red, rb0.pos, Colors::red, rb1.pos);
        drawLine(Colors::red, rb1.pos, Colors::red, rb2.pos);

        // mass points
        rb0.draw();
        rb1.draw();
        rb2.draw();

        // reset button
        if (isKeyPressedAndReleased(GLFW_KEY_R)) reset();
    }

};
```

### ë„ì „ë¬¸ì œ2
`3_3_8.png ì‚¬ì§„ ì¶”ê°€`
ë°”ë‘‘íŒ ê°™ì€ êµ¬ì¡°ë¥¼ ë§Œë“¤ì–´ Spring ì„ ì´˜ì´˜íˆ ì—°ê²°í•œë‹¤.    
ì´ëŠ” ì˜·ê° ì‹œë®¬ë ˆì´ì…˜ì— ë§ì´ ì‚¬ìš©ëœë‹¤.    
ê°€ìƒ ìºë¦­í„°ì˜ ì˜·ì´ ì…í ë•Œ ì˜·ê°ì„ Mass-Spring System ê³¼ ë¹„ìŠ·í•œ, í˜¹ì€ ì¢€ ë” ë°œì „ëœ ê¸°ìˆ ì„ ì‚¬ìš©í•´ êµ¬í˜„í•œë‹¤.    
ì¶”í›„ì— ê·¸ë˜í”½ìŠ¤ë¥¼ ê³µë¶€í•  ë•Œ 3ì°¨ì› êµ¬ì¡°ì—ì„œ ì¶œë ì´ê±°ë‚˜ ì°Œê·¸ëŸ¬ì§€ëŠ” ë¬¼ì²´ë¥¼ ì´ê²ƒê³¼ ë¹„ìŠ·í•˜ê²Œ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤.    

`3_3_9.png ì‚¬ì§„ ì¶”ê°€`
íŒíŠ¸ë¡œëŠ” ìœ„ì˜ ì‚¬ì§„ì„ ì°¸ê³ í•œë‹¤.    

```cpp
class Example : public Game2D	// Mass-Spring System Excercise 2
{
public:
    //RigidCircle rb0, rb1, rb2;	// rb0 ì€ ê³ ì •, rb1 ê³¼ rb2 ê°€ ì›€ì§ì¸ë‹¤
    RigidCircle rb[16];

    Example()
        : Game2D()
    {
        reset();
    }

    void reset()
    {
        // Initial position and velocity
        const float interval = 0.4f;
        for (unsigned i = 0; i < 16; ++i)
        {
            if (i % 4 == 0)
            {
                rb[i].pos = vec2(-0.6f, 0.6f - (i / 4) * interval);
                rb[i].vel = vec2(0.0f, 0.0f);
                rb[i].radius = 0.03f;
                if (i == 0)
                {
                    rb[i].color = Colors::yellow;
                    rb[i].mass = 1.0f;
                }
                else
                {
                    rb[i].color = Colors::blue;
                    rb[i].mass = rb[0].mass * std::pow(rb[i].radius / rb[0].radius, 2.0f);
                }
            }
            else if (i % 4 == 1)
            {
                rb[i].pos = vec2(-0.2f, 0.6f - (i / 4) * interval);
                rb[i].vel = vec2(0.0f, 0.0f);
                rb[i].color = Colors::blue;
                rb[i].radius = 0.03f;
                rb[i].mass = 1.0f;
            }
            else if (i % 4 == 2)
            {
                rb[i].pos = vec2(0.2f, 0.6f - (i / 4) * interval);
                rb[i].vel = vec2(0.0f, 0.0f);
                rb[i].color = Colors::blue;
                rb[i].radius = 0.03f;
                rb[i].mass = 1.0f;
            }
            else if (i % 4 == 3)
            {
                rb[i].pos = vec2(0.6f, 0.6f - (i / 4) * interval);
                rb[i].vel = vec2(0.0f, 0.0f);
                rb[i].radius = 0.03f;
                rb[i].color = Colors::blue;
                if (i == 3)
                {
                    rb[i].color = Colors::yellow;
                    rb[i].mass = 1.0f;
                }
                else
                {
                    rb[i].color = Colors::blue;
                    rb[i].mass = rb[0].mass * std::pow(rb[i].radius / rb[0].radius, 2.0f);
                }
            }
        }
    }

    void drawWall()
    {
        setLineWidth(5.0f);
        drawLine(Colors::blue, { -1.0f, -1.0f }, Colors::blue, { 1.0f, -1.0f });
        drawLine(Colors::blue, { 1.0f, -1.0f }, Colors::blue, { 1.0f, 1.0f });
        drawLine(Colors::blue, { -1.0f, -1.0f }, Colors::blue, { -1.0f, 1.0f });
    }

    void drawSpring()
    {
        unsigned i = 0;

        for ( ; i < 12; ++i)
        {
            if (i % 4 == 0)
            {
                drawLine(Colors::red, rb[i].pos, Colors::red, rb[i + 4].pos);
                drawLine(Colors::red, rb[i].pos, Colors::red, rb[i + 5].pos);
            }
            else if (i % 4 == 3)
            {
                drawLine(Colors::red, rb[i].pos, Colors::red, rb[i - 1].pos);
                drawLine(Colors::red, rb[i].pos, Colors::red, rb[i + 3].pos);
                drawLine(Colors::red, rb[i].pos, Colors::red, rb[i + 4].pos);
            }
            else
            {
                drawLine(Colors::red, rb[i].pos, Colors::red, rb[i - 1].pos);
                drawLine(Colors::red, rb[i].pos, Colors::red, rb[i + 3].pos);
                drawLine(Colors::red, rb[i].pos, Colors::red, rb[i + 4].pos);
                drawLine(Colors::red, rb[i].pos, Colors::red, rb[i + 5].pos);
            }
        }

        for (; i < 15; ++i)
        {
            drawLine(Colors::red, rb[i].pos, Colors::red, rb[i + 1].pos);
        }
    }

    void update() override
    {
        const float dt = getTimeStep() * 0.4f;
        const float epsilon = 0.5f;

        // physics update (Temporarily disabled)
        //rb0.update(dt);
        //rb1.update(dt);

        // coefficients	: ê³„ìˆ˜
        const vec2 gravity(0.0f, -9.8f);
        const float l0 = 0.5f;
        const float coeff_k = 100.0f;	// stiffness K
        const float coeff_d = 50.0f;	// 

        // update  (Note: rb[0], rb[3] is fixed)
        {
            for (unsigned i = 0; i < 16; ++i)
            {
                if (i != 0 && i % 4 == 0)
                {
                    const auto distance0 = (rb[i].pos - rb[i - 4].pos).getMagnitude();
                    const auto distance1 = (rb[i].pos - rb[i - 3].pos).getMagnitude();
                    const auto distance2 = (rb[i].pos - rb[i + 1].pos).getMagnitude();

                    const auto direction0 = (rb[i].pos - rb[i - 4].pos) / distance0;
                    const auto direction1 = (rb[i].pos - rb[i - 3].pos) / distance1;
                    const auto direction2 = (rb[i].pos - rb[i + 1].pos) / distance2;

                    const auto spring_force0 = direction0 * -coeff_k * (distance0 - l0);
                    const auto spring_force1 = direction1 * -coeff_k * (distance1 - l0);
                    const auto spring_force2 = direction2 * -coeff_k * (distance2 - l0);

                    const auto damping_force0 = direction0 * -coeff_d * (rb[i].pos - rb[i - 4].pos).getDotProduct(direction0);
                    const auto damping_force1 = direction1 * -coeff_d * (rb[i].pos - rb[i - 3].pos).getDotProduct(direction1);
                    const auto damping_force2 = direction2 * -coeff_d * (rb[i].pos - rb[i + 1].pos).getDotProduct(direction2);

                    if (i != 12)
                    {
                        const auto distance3 = (rb[i].pos - rb[i + 5].pos).getMagnitude();
                        const auto distance4 = (rb[i].pos - rb[i + 4].pos).getMagnitude();
                        const auto direction3 = (rb[i].pos - rb[i + 5].pos) / distance3;
                        const auto direction4 = (rb[i].pos - rb[i + 4].pos) / distance4;
                        const auto spring_force3 = direction3 * -coeff_k * (distance3 - l0);
                        const auto spring_force4 = direction4 * -coeff_k * (distance4 - l0);
                        const auto damping_force3 = direction3 * -coeff_d * (rb[i].pos - rb[i + 5].pos).getDotProduct(direction3);
                        const auto damping_force4 = direction4 * -coeff_d * (rb[i].pos - rb[i + 4].pos).getDotProduct(direction4);

                        const auto spring_force = spring_force0 + spring_force1 + spring_force2 + spring_force3 + spring_force4;
                        const auto damping_force = damping_force0 + damping_force1 + damping_force2 + damping_force3 + damping_force4;

                        const auto accel = gravity + (spring_force + damping_force) / rb[i].mass;

                        rb[i].vel += accel * dt;
                        rb[i].pos += rb[i].vel * dt;
                    }
                    else
                    {
                        const auto spring_force = spring_force0 + spring_force1 + spring_force2;
                        const auto damping_force = damping_force0 + damping_force1 + damping_force2;

                        const auto accel = gravity + (spring_force + damping_force) / rb[i].mass;

                        rb[i].vel += accel * dt;
                        rb[i].pos += rb[i].vel * dt;
                    }
                }
                else if (i != 3 && i % 4 == 3)
                {
                    const auto distance0 = (rb[i].pos - rb[i - 4].pos).getMagnitude();
                    const auto distance1 = (rb[i].pos - rb[i - 5].pos).getMagnitude();
                    const auto distance2 = (rb[i].pos - rb[i - 1].pos).getMagnitude();

                    const auto direction0 = (rb[i].pos - rb[i - 4].pos) / distance0;
                    const auto direction1 = (rb[i].pos - rb[i - 5].pos) / distance1;
                    const auto direction2 = (rb[i].pos - rb[i - 1].pos) / distance2;

                    const auto spring_force0 = direction0 * -coeff_k * (distance0 - l0);
                    const auto spring_force1 = direction1 * -coeff_k * (distance1 - l0);
                    const auto spring_force2 = direction2 * -coeff_k * (distance2 - l0);

                    const auto damping_force0 = direction0 * -coeff_d * (rb[i].pos - rb[i - 4].pos).getDotProduct(direction0);
                    const auto damping_force1 = direction1 * -coeff_d * (rb[i].pos - rb[i - 5].pos).getDotProduct(direction1);
                    const auto damping_force2 = direction2 * -coeff_d * (rb[i].pos - rb[i - 1].pos).getDotProduct(direction2);

                    if (i != 15)
                    {
                        const auto distance3 = (rb[i].pos - rb[i + 3].pos).getMagnitude();
                        const auto distance4 = (rb[i].pos - rb[i + 4].pos).getMagnitude();
                        const auto direction3 = (rb[i].pos - rb[i + 3].pos) / distance3;
                        const auto direction4 = (rb[i].pos - rb[i + 4].pos) / distance4;
                        const auto spring_force3 = direction3 * -coeff_k * (distance3 - l0);
                        const auto spring_force4 = direction4 * -coeff_k * (distance4 - l0);
                        const auto damping_force3 = direction3 * -coeff_d * (rb[i].pos - rb[i + 3].pos).getDotProduct(direction3);
                        const auto damping_force4 = direction4 * -coeff_d * (rb[i].pos - rb[i + 4].pos).getDotProduct(direction4);

                        const auto spring_force = spring_force0 + spring_force1 + spring_force2 + spring_force3 + spring_force4;
                        const auto damping_force = damping_force0 + damping_force1 + damping_force2 + damping_force3 + damping_force4;

                        const auto accel = gravity + (spring_force + damping_force) / rb[i].mass;

                        rb[i].vel += accel * dt;
                        rb[i].pos += rb[i].vel * dt;
                    }
                    else
                    {
                        const auto spring_force = spring_force0 + spring_force1 + spring_force2;
                        const auto damping_force = damping_force0 + damping_force1 + damping_force2;

                        const auto accel = gravity + (spring_force + damping_force) / rb[i].mass;

                        rb[i].vel += accel * dt;
                        rb[i].pos += rb[i].vel * dt;
                    }
                }
                else if (i % 4 == 1 || i % 4 == 2)
                {
                    const auto distance0 = (rb[i].pos - rb[i - 1].pos).getMagnitude();
                    const auto distance1 = (rb[i].pos - rb[i + 1].pos).getMagnitude();
                    const auto direction0 = (rb[i].pos - rb[i - 1].pos) / distance0;
                    const auto direction1 = (rb[i].pos - rb[i + 1].pos) / distance1;
                    const auto spring_force0 = direction0 * -coeff_k * (distance0 - l0);
                    const auto spring_force1 = direction1 * -coeff_k * (distance1 - l0);
                    const auto damping_force0 = direction0 * -coeff_d * (rb[i].pos - rb[i - 1].pos).getDotProduct(direction0);
                    const auto damping_force1 = direction1 * -coeff_d * (rb[i].pos - rb[i + 1].pos).getDotProduct(direction1);

                    if (i / 4 == 0)
                    {
                        const auto distance2 = (rb[i].pos - rb[i + 3].pos).getMagnitude();
                        const auto distance3 = (rb[i].pos - rb[i + 4].pos).getMagnitude();
                        const auto distance4 = (rb[i].pos - rb[i + 5].pos).getMagnitude();
                        const auto direction2 = (rb[i].pos - rb[i + 3].pos) / distance2;
                        const auto direction3 = (rb[i].pos - rb[i + 4].pos) / distance3;
                        const auto direction4 = (rb[i].pos - rb[i + 5].pos) / distance4;
                        const auto spring_force2 = direction2 * -coeff_k * (distance2 - l0);
                        const auto spring_force3 = direction3 * -coeff_k * (distance3 - l0);
                        const auto spring_force4 = direction4 * -coeff_k * (distance4 - l0);
                        const auto damping_force2 = direction2 * -coeff_d * (rb[i].pos - rb[i + 3].pos).getDotProduct(direction2);
                        const auto damping_force3 = direction3 * -coeff_d * (rb[i].pos - rb[i + 4].pos).getDotProduct(direction3);
                        const auto damping_force4 = direction4 * -coeff_d * (rb[i].pos - rb[i + 5].pos).getDotProduct(direction4);

                        const auto spring_force = spring_force0 + spring_force1 + spring_force2 + spring_force3 + spring_force4;
                        const auto damping_force = damping_force0 + damping_force1 + damping_force2 + damping_force3 + damping_force4;

                        const auto accel = gravity + (spring_force + damping_force) / rb[i].mass;

                        rb[i].vel += accel * dt;
                        rb[i].pos += rb[i].vel * dt;
                    }
                    else if (i / 4 == 3)
                    {
                        const auto distance2 = (rb[i].pos - rb[i - 5].pos).getMagnitude();
                        const auto distance3 = (rb[i].pos - rb[i - 4].pos).getMagnitude();
                        const auto distance4 = (rb[i].pos - rb[i - 3].pos).getMagnitude();
                        const auto direction2 = (rb[i].pos - rb[i - 5].pos) / distance2;
                        const auto direction3 = (rb[i].pos - rb[i - 4].pos) / distance3;
                        const auto direction4 = (rb[i].pos - rb[i - 3].pos) / distance4;
                        const auto spring_force2 = direction2 * -coeff_k * (distance2 - l0);
                        const auto spring_force3 = direction3 * -coeff_k * (distance3 - l0);
                        const auto spring_force4 = direction4 * -coeff_k * (distance4 - l0);
                        const auto damping_force2 = direction2 * -coeff_d * (rb[i].pos - rb[i - 5].pos).getDotProduct(direction2);
                        const auto damping_force3 = direction3 * -coeff_d * (rb[i].pos - rb[i - 4].pos).getDotProduct(direction3);
                        const auto damping_force4 = direction4 * -coeff_d * (rb[i].pos - rb[i - 3].pos).getDotProduct(direction4);

                        const auto spring_force = spring_force0 + spring_force1 + spring_force2 + spring_force3 + spring_force4;
                        const auto damping_force = damping_force0 + damping_force1 + damping_force2 + damping_force3 + damping_force4;

                        const auto accel = gravity + (spring_force + damping_force) / rb[i].mass;

                        rb[i].vel += accel * dt;
                        rb[i].pos += rb[i].vel * dt;
                    }
                    else
                    {
                        const auto distance2 = (rb[i].pos - rb[i + 3].pos).getMagnitude();
                        const auto distance3 = (rb[i].pos - rb[i + 4].pos).getMagnitude();
                        const auto distance4 = (rb[i].pos - rb[i + 5].pos).getMagnitude();
                        const auto direction2 = (rb[i].pos - rb[i + 3].pos) / distance2;
                        const auto direction3 = (rb[i].pos - rb[i + 4].pos) / distance3;
                        const auto direction4 = (rb[i].pos - rb[i + 5].pos) / distance4;
                        const auto spring_force2 = direction2 * -coeff_k * (distance2 - l0);
                        const auto spring_force3 = direction3 * -coeff_k * (distance3 - l0);
                        const auto spring_force4 = direction4 * -coeff_k * (distance4 - l0);
                        const auto damping_force2 = direction2 * -coeff_d * (rb[i].pos - rb[i + 3].pos).getDotProduct(direction2);
                        const auto damping_force3 = direction3 * -coeff_d * (rb[i].pos - rb[i + 4].pos).getDotProduct(direction3);
                        const auto damping_force4 = direction4 * -coeff_d * (rb[i].pos - rb[i + 5].pos).getDotProduct(direction4);

                        const auto distance5 = (rb[i].pos - rb[i - 5].pos).getMagnitude();
                        const auto distance6 = (rb[i].pos - rb[i - 4].pos).getMagnitude();
                        const auto distance7 = (rb[i].pos - rb[i - 3].pos).getMagnitude();
                        const auto direction5 = (rb[i].pos - rb[i - 5].pos) / distance5;
                        const auto direction6 = (rb[i].pos - rb[i - 4].pos) / distance6;
                        const auto direction7 = (rb[i].pos - rb[i - 3].pos) / distance7;
                        const auto spring_force5 = direction5 * -coeff_k * (distance5 - l0);
                        const auto spring_force6 = direction6 * -coeff_k * (distance6 - l0);
                        const auto spring_force7 = direction7 * -coeff_k * (distance7 - l0);
                        const auto damping_force5 = direction5 * -coeff_d * (rb[i].pos - rb[i - 5].pos).getDotProduct(direction5);
                        const auto damping_force6 = direction6 * -coeff_d * (rb[i].pos - rb[i - 4].pos).getDotProduct(direction6);
                        const auto damping_force7 = direction7 * -coeff_d * (rb[i].pos - rb[i - 3].pos).getDotProduct(direction7);

                        const auto spring_force = spring_force0 + spring_force1 + spring_force2 + spring_force3 + spring_force4 +
                                spring_force5 + spring_force6 + spring_force7;
                        const auto damping_force = damping_force0 + damping_force1 + damping_force2 + damping_force3 + damping_force4 + 
                            damping_force5 + damping_force6 + damping_force7;

                        const auto accel = gravity + (spring_force + damping_force) / rb[i].mass;

                        rb[i].vel += accel * dt;
                        rb[i].pos += rb[i].vel * dt;
                    }
                }
            }
        }

        // draw
        drawWall();

        // spring
        drawSpring();

        // mass points
        for (auto & e : rb)
            e.draw();

        // reset button
        if (isKeyPressedAndReleased(GLFW_KEY_R)) reset();
    }

};
```
ê²°ê³¼ë¥¼ ë– ë‚˜ì„œ ì •ë§ ë³µì¡í•˜ê³  ê°„ê²°í•˜ì§€ ì•Šì€ ì•ˆì¢‹ì€ ì½”ë“œë¡œ êµ¬í˜„í–ˆë‹¤.    
ë” ë§ì€ ê³µë¶€ì™€ ë…¸ë ¥ì´ í•„ìš”í•˜ë‹¤.

<pre>ë³¸ ë¸”ë¡œê·¸ëŠ” ê°œì¸ ê³µë¶€ ê¸°ë¡ì˜ ëª©ì ì„ ê°€ì§‘ë‹ˆë‹¤. í¬ìŠ¤íŠ¸ì˜ ë‚´ìš©ì€ ì–¸ì œë“ ì§€ ë°”ë€” ìˆ˜ ìˆìŠµë‹ˆë‹¤.</pre>{: .notice--info}