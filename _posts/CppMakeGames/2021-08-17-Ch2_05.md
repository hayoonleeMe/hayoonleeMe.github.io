---
title: "C++ Games Chapter2_5 ëª…ë ¹ íŒ¨í„´ Command Pattern"
excerpt: "ëª…ë ¹ íŒ¨í„´ Command Pattern"
categories:
  - Cpp MakeGames
tags:
  - Cpp
last_modified_at: 2021-08-17
toc: true
toc_sticky: true
toc_label: "ëª©ì°¨ğŸ‘€"
---

<pre>ë³¸ í•„ê¸°ëŠ” ì¸í”„ëŸ°ì˜ í™ì •ëª¨ êµìˆ˜ë‹˜ì˜ ê°•ì˜ì¸ <b>í™ì •ëª¨ì˜ ê²Œì„ ë§Œë“¤ê¸° ì—°ìŠµ ë¬¸ì œ íŒ¨í‚¤ì§€</b> ë¥¼ ë“£ê³  ì‘ì„±í•©ë‹ˆë‹¤.</pre>{: .notice--success}

### ëª…ë ¹ íŒ¨í„´ Command Pattern
ê²Œì„ì—ì„œëŠ” ìºë¦­í„°ê°€ ë‹¤ì–‘í•œ ê¸°ëŠ¥ì„ ìˆ˜í–‰í•˜ë„ë¡ ëª…ë ¹ì„ ë‚´ë¦´ ìˆ˜ ìˆì–´ì•¼ í•œë‹¤.    
ì—¬ê¸°ì„œëŠ” ëª…ë ¹ ìì²´ë¥¼ ê°ì²´ë¡œ ë§Œë“¤ì–´ì„œ ë³´ë‹¤ í¬ê³  ë³µì¡í•œ ê²Œì„ ì‹œìŠ¤í…œì—ì„œë„ ìœ ì—°í•˜ê²Œ í”„ë¡œê·¸ë˜ë° í•  ìˆ˜ ìˆëŠ” ëª…ë ¹ íŒ¨í„´ì´ë‹¤.

```cpp
// in TankExample.h
#pragma once

#include "Game2D.h"
#include <map>

namespace jm
{
    class Actor		// ê²Œì„ ë‚´ì˜ ì˜¤ë¸Œì íŠ¸ ë“¤ì˜ ë¶€ëª¨ í´ë˜ìŠ¤ , ê¸°ëŠ¥ì„ ë‚˜íƒ€ë‚´ëŠ” í•¨ìˆ˜ë¥¼ ìˆœìˆ˜ ê°€ìƒí•¨ìˆ˜ë¡œ ê°€ì§€ê³  ìˆë‹¤.
    {
    public:
        virtual void moveUp(float dt) = 0;
    };

    class Command	// Actor ë“¤ì—ê²Œ ì‹œí‚¬ ëª…ë ¹ë“¤ì˜ ë¶€ëª¨ í´ë˜ìŠ¤ , ëª…ë ¹ì‹œí‚¤ëŠ” í•¨ìˆ˜ë¥¼ ìˆœìˆ˜ ê°€ìƒí•¨ìˆ˜ë¡œ ê°€ì§€ê³  ìˆë‹¤.
    {
    public:
        virtual ~Command() {}
        virtual void execute(Actor& actor, float dt) = 0;
    };

    class UpCommand : public Command	// moveUp ì„ ì‹œí‚¤ëŠ” ëª…ë ¹ í´ë˜ìŠ¤
    {
    public:
        // ëª…ë ¹ì„ ìˆ˜í–‰í•´ì•¼ í•˜ëŠ” actor ë¥¼ Actor& ë¡œ ë°›ì•„ì„œ ì¢€ ë” ì¶”ìƒí™” í•œë‹¤.
        virtual void execute(Actor& actor, float dt) override	
        {
            actor.moveUp(dt);
        }
    };

    class MyTank : public Actor
    {
    public:
        vec2 center = vec2(0.0f, 0.0f);
        //vec2 direction = vec2(1.0f, 0.0f, 0.0f);

        void moveUp(float dt) override	// Actor í´ë˜ìŠ¤ì˜ ê¸°ëŠ¥ í•¨ìˆ˜ë¥¼ ì˜¤ë²„ë¼ì´ë”©í•œë‹¤.
        {
            center.y += 0.5f * dt;
        }

        void draw()
        {
            beginTransformation();
            {
                translate(center);
                drawFilledBox(Colors::green, 0.25f, 0.1f); // body
                translate(-0.02f, 0.1f);
                drawFilledBox(Colors::blue, 0.15f, 0.09f); // turret
                translate(0.15f, 0.0f);
                drawFilledBox(Colors::red, 0.15f, 0.03f);  // barrel
            }
            endTransformation();
        }
    };

    class InputHandler	// ì›ë˜ êµ¬í˜„í–ˆë˜ í‚¤ë³´ë“œ ì…ë ¥ì„ ê°ì§€í•˜ëŠ” ë¶€ë¶„ì„ ë‹´ë‹¹í•˜ëŠ” í´ë˜ìŠ¤.
    {
    public:
        Command * button_up = nullptr;

        InputHandler()
        {
            button_up = new UpCommand;
        }

        void handleInput(Game2D & game, Actor & actor, float dt)
        {
            if (game.isKeyPressed(GLFW_KEY_UP))  button_up->execute(actor, dt);
        }
    };

    class TankExample : public Game2D
    {
    public:
        MyTank tank;

        InputHandler input_handler;     // ë³„ë„ì˜ InputHandler ë¥¼ ê°€ì§„ë‹¤.

    public:
        TankExample()
            : Game2D("This is my digital canvas!", 1024, 768, false, 2)
        {
           
        }

        ~TankExample()
        {
        }

        void update() override
        {
            // ì…ë ¥ì„ ê°ì§€í•˜ì—¬ ê¸°ëŠ¥ì„ ìˆ˜í–‰í•˜ëŠ” ê¸°ì¡´ì˜ ë°©ì‹ì´ë‹¤.
            // update í•¨ìˆ˜ê°™ì´ ì¤‘ìš”í•œ ê¸°ëŠ¥ì„ í•˜ëŠ” ì—”ì§„ì˜ ë‚´ìš©ì„ ê±´ë“¤ì§€ ì•Šë„ë¡ í”„ë¡œê·¸ë˜ë°í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.
            // move tank		
            /*if (isKeyPressed(GLFW_KEY_LEFT))	tank.center.x -= 0.5f * getTimeStep();
            if (isKeyPressed(GLFW_KEY_RIGHT))	tank.center.x += 0.5f * getTimeStep();
            if (isKeyPressed(GLFW_KEY_UP))      tank.center.y += 0.5f * getTimeStep();
            if (isKeyPressed(GLFW_KEY_DOWN))	tank.center.y -= 0.5f * getTimeStep();*/

            input_handler.handleInput(*this, tank, getTimeStep());

            // rendering
            tank.draw();
        }
    };
}

// in main.cpp
#include "Game2D.h"
#include "Examples/PrimitivesGallery.h"
#include "Examples/TankExample.h"
#include "RandomNumberGenerator.h"
#include <vector>
#include <memory>

namespace jm
{
}

int main(void)
{
    jm::TankExample().run();

    return 0;
}
```

### í‚¤ ì…ë ¥ì„ ìœ ì—°í•˜ê²Œ ê°ì§€í•˜ê¸°
```cpp
class InputHandler	// ì›ë˜ êµ¬í˜„í–ˆë˜ í‚¤ë³´ë“œ ì…ë ¥ì„ ê°ì§€í•˜ëŠ” ë¶€ë¶„ì„ ë‹´ë‹¹í•˜ëŠ” í´ë˜ìŠ¤.
{
public:
    Command * button_up = nullptr;

    std::map<int, Command *> key_command_map;

    InputHandler()
    {
        button_up = new UpCommand;
    }

    void handleInput(Game2D & game, Actor & actor, float dt)
    {
        //if (game.isKeyPressed(GLFW_KEY_UP))  button_up->execute(actor, dt);

        for (auto & m : key_command_map)
        {
            if (game.isKeyPressed(m.first)) m.second->execute(actor, dt);
        }
    }
};

class TankExample : public Game2D
{
public:
    MyTank tank;

    InputHandler input_handler;		// ë³„ë„ì˜ InputHandler ë¥¼ ê°€ì§„ë‹¤.

public:
    TankExample()
        : Game2D("This is my digital canvas!", 1024, 768, false, 2)
    {
        //key mapping
        input_handler.key_command_map[GLFW_KEY_UP] = new UpCommand;
    }

    ~TankExample()
    {
    }

    void update() override
    {
        // ì…ë ¥ì„ ê°ì§€í•˜ì—¬ ê¸°ëŠ¥ì„ ìˆ˜í–‰í•˜ëŠ” ê¸°ì¡´ì˜ ë°©ì‹ì´ë‹¤. 
        // update í•¨ìˆ˜ê°™ì´ ì¤‘ìš”í•œ ê¸°ëŠ¥ì„ í•˜ëŠ” ì—”ì§„ì˜ ë‚´ìš©ì„ ê±´ë“¤ì§€ ì•Šë„ë¡ í”„ë¡œê·¸ë˜ë°í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.
        // move tank		
        /*if (isKeyPressed(GLFW_KEY_LEFT))	tank.center.x -= 0.5f * getTimeStep();
        if (isKeyPressed(GLFW_KEY_RIGHT))	tank.center.x += 0.5f * getTimeStep();
        if (isKeyPressed(GLFW_KEY_UP))		tank.center.y += 0.5f * getTimeStep();
        if (isKeyPressed(GLFW_KEY_DOWN))	tank.center.y -= 0.5f * getTimeStep();*/

        input_handler.handleInput(*this, tank, getTimeStep());

        // rendering
        tank.draw();
    }
};
```
map ìë£Œêµ¬ì¡°ë¥¼ ì´ìš©í•´ì„œ GLFW_KEY ì˜ Flag ì˜ ê°’ì— ë”°ë¼ Command ì˜ í¬ì¸í„°ë¥¼ mapping ì‹œì¼œì„œ for each ë¬¸ìœ¼ë¡œ ì°¾ì•„ì„œ ì‚¬ìš©í•˜ë„ë¡ í•œë‹¤.    
ì´ë•Œ mapping ì€ ì´ˆê¸°í™” í•  ë•Œ í•œë²ˆì— mapping í•œë‹¤.
<pre>info notice :
GLFW_KEY ì˜ Flag ê°’ì€ ì˜ëª» ë“¤ì–´ì™”ì„ ë•Œ -1 ì„ ê°€ì§€ê¸° ë•Œë¬¸ì— signed int ë¡œ ë°›ëŠ”ë‹¤.</pre>{: .notice--warning}

ê²Œì„ì—ì„œ í‚¤ì„¤ì •ì„ ë³€ê²½í•  ìˆ˜ ìˆëŠ” ê²ƒì€ ëª…ë ¹ íŒ¨í„´ì˜ í‚¤ mapping ì„ í†µí•´ì„œ ê·¸ë•Œê·¸ë•Œ í‚¤ì— í•´ë‹¹í•˜ëŠ” Command í´ë˜ìŠ¤ë¥¼ ë³€ê²½í•˜ëŠ” ê²ƒì´ë‹¤.

### ì‹¤ìŠµë¬¸ì œ
ëª…ë ¹ íŒ¨í„´ì„ ì´ìš©í•´ ì•„ë˜, ì™¼ìª½, ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì´ë™í•˜ëŠ” ê¸°ëŠ¥ì„ ì¶”ê°€í•œë‹¤.    
ì´ì•Œì„ ë°œì‚¬í•˜ëŠ” ê¸°ëŠ¥ì„ ì¶”ê°€í•˜ê³  ì—¬ëŸ¬ê°œì˜ ì´ì•Œì„ ë°œì‚¬í•  ìˆ˜ ìˆë„ë¡ ë§Œë“ ë‹¤.    
ì´ë•Œ ì´ì•Œì´ í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ì§€ìš°ë„ë¡ í•œë‹¤.    
ì´ì•Œì„ ë°œì‚¬í•˜ë©´ 1ì´ˆì˜ ëŒ€ê¸°ì‹œê°„ í›„ ë‹¤ì‹œ ë°œì‚¬í•  ìˆ˜ ìˆë„ë¡ í•œë‹¤.    
map ì„ ì´ìš©í•œ í‚¤ ë°”ì¸ë”© ì‹œì— í…ìŠ¤íŠ¸ íŒŒì¼ì—ì„œ ì½ì–´ë“¤ì¸ ëŒ€ë¡œ í‚¤ ë°”ì¸ë”© í•˜ë„ë¡ í•œë‹¤.

```cpp
// in key_binding.txt
SPACE shoot
W move_up
S move_down
A move_left
D move_right

// in TankExample.h
#pragma once

#include "Game2D.h"
#include <map>
#include <fstream>
#include <string>
#include <chrono>

namespace jm
{
    class Actor		// ê²Œì„ ë‚´ì˜ ì˜¤ë¸Œì íŠ¸ ë“¤ì˜ ë¶€ëª¨ í´ë˜ìŠ¤ , ê¸°ëŠ¥ì„ ë‚˜íƒ€ë‚´ëŠ” í•¨ìˆ˜ë¥¼ ìˆœìˆ˜ ê°€ìƒí•¨ìˆ˜ë¡œ ê°€ì§€ê³  ìˆë‹¤.
    {
    public:
        virtual void moveUp(float dt) = 0;
        virtual void moveDown(float dt) = 0;
        virtual void moveLeft(float dt) = 0;
        virtual void moveRight(float dt) = 0;
        
        virtual void fireBullet(float dt) = 0;
    };

    class Command	// Actor ë“¤ì—ê²Œ ì‹œí‚¬ ëª…ë ¹ë“¤ì˜ ë¶€ëª¨ í´ë˜ìŠ¤ , ëª…ë ¹ì‹œí‚¤ëŠ” í•¨ìˆ˜ë¥¼ ìˆœìˆ˜ ê°€ìƒí•¨ìˆ˜ë¡œ ê°€ì§€ê³  ìˆë‹¤.
    {
    public:
        virtual ~Command() {}
        virtual void execute(Actor& actor, float dt) = 0;
    };

    class UpCommand : public Command	// moveUp ì„ ì‹œí‚¤ëŠ” ëª…ë ¹ í´ë˜ìŠ¤
    {
    public:
        // ëª…ë ¹ì„ ìˆ˜í–‰í•´ì•¼ í•˜ëŠ” actor ë¥¼ Actor& ë¡œ ë°›ì•„ì„œ ì¢€ ë” ì¶”ìƒí™” í•œë‹¤.
        virtual void execute(Actor& actor, float dt) override	
        {
            actor.moveUp(dt);
        }
    };

    class DownCommand : public Command	
    {
    public:
        virtual void execute(Actor& actor, float dt) override	
        {
            actor.moveDown(dt);
        }
    };

    class LeftCommand : public Command
    {
    public:
        virtual void execute(Actor& actor, float dt) override
        {
            actor.moveLeft(dt);
        }
    };

    class RightCommand : public Command
    {
    public:
        virtual void execute(Actor& actor, float dt) override
        {
            actor.moveRight(dt);
        }
    };

    class FireBulletCommand : public Command
    {
    public:
        virtual void execute(Actor& actor, float dt) override
        {
            actor.fireBullet(dt);
        }
    };

    class MyBullet
    {
    public:
        vec2 center = vec2(0.0f, 0.0f);
        vec2 velocity = vec2(1.0f, 0.0f);
        float dt = 0.0f;

        MyBullet(const vec2 & _pos, const float & _x, const float & _y, const float & _dt)
        {
            center = _pos;
            center.x += _x;
            center.y += _y;
            dt = _dt;
        }

        ~MyBullet()
        {
            //printf("bullet is destroyed\n");
        }

        void draw()
        {
            center += velocity * dt;

            beginTransformation();
            {
                translate(center);
                drawFilledRegularConvexPolygon(Colors::yellow, 0.02f, 8);
                drawWiredRegularConvexPolygon(Colors::gray, 0.02f, 8);
            }
            endTransformation();
        }
    };

    class MyTank : public Actor
    {
    public:
        std::vector<MyBullet *> my_bullets;

        bool canFire = true;
        std::chrono::steady_clock::time_point begin, end;

        vec2 center = vec2(0.0f, 0.0f);
        //vec2 direction = vec2(1.0f, 0.0f, 0.0f);

        ~MyTank()
        {
            for (const auto & bullet : my_bullets)
            {
                delete bullet;
            }
        }

        void moveUp(float dt) override		// Actor í´ë˜ìŠ¤ì˜ ê¸°ëŠ¥ í•¨ìˆ˜ë¥¼ ì˜¤ë²„ë¼ì´ë”©í•œë‹¤.
        {
            center.y += 0.5f * dt;
        }

        void moveDown(float dt) override
        {
            center.y -= 0.5f * dt;
        }

        void moveLeft(float dt) override
        {
            center.x -= 0.5f * dt;
        }

        void moveRight(float dt) override
        {
            center.x += 0.5f * dt;
        }

        void fireBullet(float dt) override
        {
            if (canFire)
            {
                my_bullets.push_back(new MyBullet(this->center, 0.2f, 0.1f, dt));
                canFire = false;
                begin = std::chrono::steady_clock::now();
            }
            else
                // ì´ì•Œì„ ë°œì‚¬í•˜ê³  1ì´ˆê°€ ì§€ë‚˜ì•¼ë§Œ ë‹¤ì‹œ ë°œì‚¬í•  ìˆ˜ ìˆë‹¤.
                if (std::chrono::duration_cast<std::chrono::seconds>	
                    (std::chrono::steady_clock::now() - begin).count() >= 1.0f)
                    canFire = true;
        }

        void draw()
        {
            beginTransformation();
            {
                translate(center);
                drawFilledBox(Colors::green, 0.25f, 0.1f); // body
                translate(-0.02f, 0.1f);
                drawFilledBox(Colors::blue, 0.15f, 0.09f); // turret
                translate(0.15f, 0.0f);
                drawFilledBox(Colors::red, 0.15f, 0.03f);  // barrel
            }
            endTransformation();

            for (const auto & bullet : my_bullets)	// bullet ì„ ê·¸ë¦°ë‹¤.
                bullet->draw();

            // í™”ë©´ ë°–ì„ ë„˜ì–´ê°€ëŠ” bullet ì„ ì œê±°í•œë‹¤.
            for (auto iter = my_bullets.begin(); iter != my_bullets.end(); )	
            { 
                if ((*iter)->center.x >= 1.4f)
                {
                    MyBullet * temp = *iter;
                    iter = my_bullets.erase(iter); // eraseí•¨ìˆ˜ëŠ” í•´ë‹¹ ìš”ì†Œë¥¼ ì œê±°í•˜ê³  ê·¸ ë‹¤ìŒ ìš”ì†Œì˜ iterë¥¼ ë°˜í™˜
                    delete temp;
                }
                else 
                    iter++; // ì œê±°í•˜ì§€ ì•Šì„ ë•ŒëŠ” ê·¸ëƒ¥ ì¦ê°€
            }
        }
    }; 

    class InputHandler	// ì›ë˜ êµ¬í˜„í–ˆë˜ í‚¤ë³´ë“œ ì…ë ¥ì„ ê°ì§€í•˜ëŠ” ë¶€ë¶„ì„ ë‹´ë‹¹í•˜ëŠ” í´ë˜ìŠ¤.
    {
    public:
        /*Command * button_up = nullptr;
        Command * button_down = nullptr;
        Command * button_left = nullptr;
        Command * button_right = nullptr;

        Command * button_fire = nullptr;*/

        std::map<int, Command *> key_command_map;	

        InputHandler()
        {
            /*button_up = new UpCommand;
            button_down = new DownCommand;
            button_left = new LeftCommand;
            button_right = new RightCommand;
            button_fire = new FireBulletCommand;*/
        }

        void handleInput(Game2D & game, Actor & actor, float dt)
        {
            /*if (game.isKeyPressed(GLFW_KEY_UP))  button_up->execute(actor, dt);
            if (game.isKeyPressed(GLFW_KEY_DOWN))  button_down->execute(actor, dt);
            if (game.isKeyPressed(GLFW_KEY_LEFT))  button_left->execute(actor, dt);
            if (game.isKeyPressed(GLFW_KEY_RIGHT))  button_right->execute(actor, dt);
            if (game.isKeyPressedAndReleased(GLFW_KEY_SPACE)) button_fire->execute(actor, dt);*/

            for (auto & m : key_command_map)
                if (game.isKeyPressed(m.first)) m.second->execute(actor, dt);
        }
    };

    class TankExample : public Game2D
    {
    public:
        MyTank tank;

        InputHandler input_handler;		// ë³„ë„ì˜ InputHandler ë¥¼ ê°€ì§„ë‹¤.

        std::map<std::string, int> key = { {"SPACE", GLFW_KEY_SPACE}, {"W", GLFW_KEY_W}, {"S", GLFW_KEY_S}, 
        {"A", GLFW_KEY_A}, {"D", GLFW_KEY_D} };

        std::map<std::string, Command *> func = { {"shoot", new FireBulletCommand}, {"move_up", new UpCommand}, 
        {"move_down", new DownCommand}, {"move_left", new LeftCommand}, {"move_right", new RightCommand} };

    public:
        TankExample()
            : Game2D("This is my digital canvas!", 1024, 768, false, 2)
        {
            std::ifstream ifs("key_binding.txt");
            if (!ifs)
            {
                std::cerr << "Cannot open file" << std::endl;
                exit(1);
            }

            while (ifs)
            {
                std::string str1, str2;
                ifs >> str1 >> str2;
                input_handler.key_command_map[key[str1]] = func[str2];
            }

            //key mapping
            /*input_handler.move_key_command_map[GLFW_KEY_UP] = new UpCommand;
            input_handler.move_key_command_map[GLFW_KEY_DOWN] = new DownCommand;
            input_handler.move_key_command_map[GLFW_KEY_LEFT] = new LeftCommand;
            input_handler.move_key_command_map[GLFW_KEY_RIGHT] = new RightCommand;
            input_handler.move_key_command_map[GLFW_KEY_SPACE] = new FireBulletCommand;*/
        }

        ~TankExample()
        {
        }
        
        void update() override
        {
            // ì…ë ¥ì„ ê°ì§€í•˜ì—¬ ê¸°ëŠ¥ì„ ìˆ˜í–‰í•˜ëŠ” ê¸°ì¡´ì˜ ë°©ì‹ì´ë‹¤. 
            // update í•¨ìˆ˜ê°™ì´ ì¤‘ìš”í•œ ê¸°ëŠ¥ì„ í•˜ëŠ” ì—”ì§„ì˜ ë‚´ìš©ì„ ê±´ë“¤ì§€ ì•Šë„ë¡ í”„ë¡œê·¸ë˜ë°í•˜ëŠ” ê²ƒì´ ì¢‹ë‹¤.
            // move tank		
            /*if (isKeyPressed(GLFW_KEY_LEFT))	tank.center.x -= 0.5f * getTimeStep();
            if (isKeyPressed(GLFW_KEY_RIGHT))	tank.center.x += 0.5f * getTimeStep();
            if (isKeyPressed(GLFW_KEY_UP))		tank.center.y += 0.5f * getTimeStep();
            if (isKeyPressed(GLFW_KEY_DOWN))	tank.center.y -= 0.5f * getTimeStep();*/

            input_handler.handleInput(*this, tank, getTimeStep());

            // rendering
            tank.draw();
        }
    };
}
```

<pre>ë³¸ ë¸”ë¡œê·¸ëŠ” ê°œì¸ ê³µë¶€ ê¸°ë¡ì˜ ëª©ì ì„ ê°€ì§‘ë‹ˆë‹¤. í¬ìŠ¤íŠ¸ì˜ ë‚´ìš©ì€ ì–¸ì œë“ ì§€ ë°”ë€” ìˆ˜ ìˆìŠµë‹ˆë‹¤.</pre>{: .notice--info}