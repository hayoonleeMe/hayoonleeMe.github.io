---
title: "C++ Games Chapter2_6 ì‹±ê¸€í†¤ Singleton íŒ¨í„´ ì‚¬ìš´ë“œ ì—”ì§„ ì˜ˆì œ"
excerpt: "ì‹±ê¸€í†¤ Singleton íŒ¨í„´ ì‚¬ìš´ë“œ ì—”ì§„ ì˜ˆì œ"
categories:
  - Cpp MakeGames
tags:
  - Cpp
last_modified_at: 2021-08-19
toc: true
toc_sticky: true
toc_label: "ëª©ì°¨ğŸ‘€"
---

<pre>ë³¸ í•„ê¸°ëŠ” ì¸í”„ëŸ°ì˜ í™ì •ëª¨ êµìˆ˜ë‹˜ì˜ ê°•ì˜ì¸ <b>í™ì •ëª¨ì˜ ê²Œì„ ë§Œë“¤ê¸° ì—°ìŠµ ë¬¸ì œ íŒ¨í‚¤ì§€</b> ë¥¼ ë“£ê³  ì‘ì„±í•©ë‹ˆë‹¤.</pre>{: .notice--success}

### ì‹±ê¸€í†¤ Singleton íŒ¨í„´
ì–´ë–¤ í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ê°€ í”„ë¡œê·¸ë¨ ì „ì²´ì—ì„œ ë‹¨ í•˜ë‚˜ë§Œ ë§Œë“¤ì–´ì§€ë„ë¡ í•´ì¤€ë‹¤.    
í•˜ë“œì›¨ì–´ì™€ ì—°ê´€ì´ ëœ ë””ìŠ¤í”Œë ˆì´, ê·¸ë˜í”½ìŠ¤ ì—”ì§„ì´ë‚˜ ì‚¬ìš´ë“œ ì—”ì§„ì— ì¢…ì¢… ì‚¬ìš©ë˜ê³¤ í•œë‹¤.    
<pre>info notice :
ì¦‰, ì‹±ê¸€í†¤ì„ ì‚¬ìš©í•˜ëŠ” ì´ìœ ëŠ” ê¸°ë³¸ì ìœ¼ë¡œ í”„ë¡œê·¸ë¨ ì „ì²´ì—ì„œ ì „ë°˜ì ìœ¼ë¡œ ì‚¬ìš©ë˜ëŠ” ëª¨ë“ˆ(ì‚¬ìš´ë“œ ì—”ì§„, ê·¸ë˜í”½ ì—”ì§„ ë“±) ì„ 
ì½”ë“œì˜ ì–´ëŠ ë¶€ë¶„ì—ì„œë“  ì ‘ê·¼í•  ìˆ˜ ìˆê²Œ í•˜ê¸° ìœ„í•´ì„œ ì‚¬ìš©í•œë‹¤.</pre>{: .notice--warning}

í•´ë‹¹ ì˜ˆì œëŠ” ì„¤ëª…ì„ ìœ„í•´ ë‹¤ì†Œ ë¹„íš¨ìœ¨ì ì¸ ë¶€ë¶„ì´ ìˆê³  ì‹¤ë¬´ì—ì„œ ì‚¬ìš©í•˜ê¸°ì—ëŠ” ë¶€ì í•©í•˜ë‹¤.

#### ì‹±ê¸€í†¤ íŒ¨í„´ì„ ì‚¬ìš©í•˜ì§€ ì•Šì€ ì‚¬ìš´ë“œ ì—”ì§„ ì‚¬ìš©

```cpp
// in TankExample.h
#pragma once

#include "Game2D.h"
#include "MyBullet.h"
#include "MyTank.h"
#include "SoundEngine.h"
//#include "SoundEngine_Singleton.h"

namespace jm
{
    class TankExample : public Game2D
    {
    public:
        MyTank tank;

        MyBullet *bullet = nullptr;
        //TODO: allow multiple bullets
        //TODO: delete bullets when they go out of the screen

        SoundEngine sound_engine;

    public:
        TankExample()
            : Game2D("This is my digital canvas!", 1024, 768, false, 2)
        {
            //auto & sound_engine = *SoundEngine_Singleton::getInstance();

            sound_engine.createSound("drumloop.wav", "background_music", true);
            sound_engine.createSound("truck_idle_off_02.wav", "tank_move", true);
            sound_engine.createSound("cannon1.wav", "cannon", false);
            sound_engine.createSound("missile.mp3", "missile", false);

            sound_engine.playSound("background_music");
        }

        ~TankExample()
        {
            if(bullet != nullptr) delete bullet;
        }

        void update() override
        {
            //auto & sound_engine = *SoundEngine_Singleton::getInstance();

            // move tank
            bool is_moving = false;

            if (isKeyPressed(GLFW_KEY_LEFT)) {
                tank.moveLeft(getTimeStep());
                is_moving = true;
            }

            if (isKeyPressed(GLFW_KEY_RIGHT)) {
                tank.moveRight(getTimeStep());
                is_moving = true;
            }

            if (isKeyPressed(GLFW_KEY_UP)) {
                tank.moveUp(getTimeStep());
                is_moving = true;
            }

            if (isKeyPressed(GLFW_KEY_DOWN)) {
                tank.moveDown(getTimeStep());
                is_moving = true;
            }

            if(is_moving)
                sound_engine.playSound("tank_move");
            else
                sound_engine.stopSound("tank_move");

            // shoot a cannon ball
            if (isKeyPressedAndReleased(GLFW_KEY_SPACE))
            {
                if (bullet != nullptr) delete bullet;

                bullet = new MyBullet;
                bullet->center = tank.center;
                bullet->center.x += 0.2f;
                bullet->center.y += 0.1f;
                bullet->velocity = vec2(2.0f, 0.0f);

                sound_engine.stopSound("cannon");
                sound_engine.playSound("cannon");				
            }

            if (bullet != nullptr) bullet->update(getTimeStep());

            // rendering
            tank.draw();
            if (bullet != nullptr) bullet->draw();
        }
    };
}
```
```cpp
// in SoundEngine.h
#pragma once

#include "fmod.hpp"
#include <iostream>
#include <map>
#include <string>

namespace jm
{
//Note: This example implementation of sound engine is inefficient.
    class SoundEngine
    {
    private:
        FMOD::System  *system = nullptr;
        //FMOD::Channel *channel = nullptr;
        std::map<std::string, FMOD::Sound*> sound_map;
        std::map<FMOD::Sound*, FMOD::Channel*> channel_map;// not efficient (í•œ ì±„ë„ì— í•œ ì‚¬ìš´ë“œê°€ ì¬ìƒë˜ëŠ” ê²ƒì€ ë¹„íš¨ìœ¨ì )
        
        FMOD_RESULT   result;
        unsigned int  version;
        void          *extradriverdata = nullptr;

    public:
        SoundEngine()
        {
            using namespace std;

            result = FMOD::System_Create(&system);
            if (result != FMOD_OK) {
                cout << "FMOD::System_Create() fail" << endl;
                exit(-1);
            }

            result = system->getVersion(&version);
            if (result != FMOD_OK) {
                cout << "getVersion() fail" << endl;
                exit(-1);
            }
            else printf("FMOD version %08x\n", version);

            result = system->init(32, FMOD_INIT_NORMAL, extradriverdata);
            if (result != FMOD_OK) {
                cout << "system->init() fail" << endl;
                exit(-1);
            }
        }

    public:
        ~SoundEngine()
        {
            system->release();
        }

        void createSound(const std::string & filename, const std::string & sound_name, const bool & use_loop)
        {
            sound_map[sound_name] = nullptr;

            auto & sound_ptr = sound_map[sound_name];

            const int loop_flag = use_loop ? FMOD_LOOP_NORMAL : FMOD_LOOP_OFF;

            result = system->createSound(filename.c_str(), loop_flag, 0, &sound_ptr);
            
            if (result != FMOD_OK) {
                std::cout << "system->createSound() fail" << std::endl;
                exit(-1);
            }
        }

        void playSound(const std::string & sound_name)
        {
            if (sound_map.count(sound_name) <= 0) {
                std::cout << sound_name << " isn't initialized." << std::endl;
                exit(-1);
            }

            const auto & sound_ptr = sound_map[sound_name];
            auto & channel_ptr = channel_map[sound_ptr];

            bool is_playing = false;
            result = channel_ptr->isPlaying(&is_playing);

            if (is_playing) return; // don't play if this is already playing

            result = system->playSound(sound_ptr, 0, false, &channel_ptr);

            if (result != FMOD_OK) {
                std::cout << "system->playSound() fail" << std::endl;
                exit(-1);
            }
        }

        void stopSound(const std::string & sound_name)
        {
            if (sound_map.count(sound_name) <= 0) {
                std::cout << sound_name << " isn't initialized." << std::endl;
                exit(-1);
            }

            const auto & sound_ptr = sound_map[sound_name];
            auto & channel_ptr = channel_map[sound_ptr];

            bool is_playing = false;
            result = channel_ptr->isPlaying(&is_playing);

            if (is_playing == false) return; // don't stop playing if this is not playing

            result = channel_ptr->stop();

            if (result != FMOD_OK) {
                std::cout << "system->playSound() fail" << std::endl;
                exit(-1);
            }
        }
    };
}
```

#### ì‹±ê¸€í†¤ íŒ¨í„´ì„ ì‚¬ìš©í•œ ì‚¬ìš´ë“œ ì—”ì§„ ì‚¬ìš©
```cpp
// in SoundEngine_Singleton.h
#pragma once

#include "fmod.hpp"
#include <iostream>
#include <map>
#include <string>

namespace jm
{
//Note: This example implementation of sound engine is inefficient.
    class SoundEngine_Singleton
    {
    private:
        FMOD::System  *system = nullptr;
        //FMOD::Channel *channel = nullptr;
        std::map<std::string, FMOD::Sound*> sound_map;
        std::map<FMOD::Sound*, FMOD::Channel*> channel_map;// not efficient
        
        FMOD_RESULT   result;
        unsigned int  version;
        void          *extradriverdata = nullptr;

        static SoundEngine_Singleton * instance;

    public:
        static SoundEngine_Singleton * getInstance();

    private:	// ìƒì„±ìê°€ private ì´ë‹¤. -> ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ë¶ˆê°€
        SoundEngine_Singleton()
        {
            using namespace std;

            result = FMOD::System_Create(&system);
            if (result != FMOD_OK) {
                cout << "FMOD::System_Create() fail" << endl;
                exit(-1);
            }

            result = system->getVersion(&version);
            if (result != FMOD_OK) {
                cout << "getVersion() fail" << endl;
                exit(-1);
            }
            else printf("FMOD version %08x\n", version);

            result = system->init(32, FMOD_INIT_NORMAL, extradriverdata);
            if (result != FMOD_OK) {
                cout << "system->init() fail" << endl;
                exit(-1);
            }
        }

    public:
        ~SoundEngine_Singleton()
        {
            system->release();
        }

        void createSound(const std::string & filename, const std::string & sound_name, const bool & use_loop)
        {
            sound_map[sound_name] = nullptr;

            auto & sound_ptr = sound_map[sound_name];

            const int loop_flag = use_loop ? FMOD_LOOP_NORMAL : FMOD_LOOP_OFF;

            result = system->createSound(filename.c_str(), loop_flag, 0, &sound_ptr);
            
            if (result != FMOD_OK) {
                std::cout << "system->createSound() fail" << std::endl;
                exit(-1);
            }
        }

        void playSound(const std::string & sound_name)
        {
            if (sound_map.count(sound_name) <= 0) {
                std::cout << sound_name << " isn't initialized." << std::endl;
                exit(-1);
            }

            const auto & sound_ptr = sound_map[sound_name];
            auto & channel_ptr = channel_map[sound_ptr];

            bool is_playing = false;
            result = channel_ptr->isPlaying(&is_playing);

            if (is_playing) return; // don't play if this is already playing

            result = system->playSound(sound_ptr, 0, false, &channel_ptr);

            if (result != FMOD_OK) {
                std::cout << "system->playSound() fail" << std::endl;
                exit(-1);
            }
        }

        void stopSound(const std::string & sound_name)
        {
            if (sound_map.count(sound_name) <= 0) {
                std::cout << sound_name << " isn't initialized." << std::endl;
                exit(-1);
            }

            const auto & sound_ptr = sound_map[sound_name];
            auto & channel_ptr = channel_map[sound_ptr];

            bool is_playing = false;
            result = channel_ptr->isPlaying(&is_playing);

            if (is_playing == false) return; // don't stop playing if this is not playing

            result = channel_ptr->stop();

            if (result != FMOD_OK) {
                std::cout << "system->playSound() fail" << std::endl;
                exit(-1);
            }
        }
    };
}
```
SoundEngine_Singleton í´ë˜ìŠ¤ì˜ ìƒì„±ìëŠ” private ì´ê¸° ë•Œë¬¸ì— ì™¸ë¶€ì—ì„œ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ë‹¤.    
ë˜í•œ í´ë˜ìŠ¤ì˜ ë©¤ë²„ ë³€ìˆ˜ë¡œ static ì¸ SoundEngine_Singleton ì˜ í¬ì¸í„°ë¥¼ ê°€ì§€ê³  ìˆê¸° ë•Œë¬¸ì— SoundEngine_Singleton í´ë˜ìŠ¤ ì—ì„œë§Œ ì¡´ì¬í•œë‹¤.     
ë˜í•œ static ì¸ getInstance í•¨ìˆ˜ë¥¼ í†µí•´ì„œë§Œ í•´ë‹¹ í¬ì¸í„°ì— ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤.  

```cpp
#pragma once

#include "Game2D.h"
#include "MyBullet.h"
#include "MyTank.h"
//#include "SoundEngine.h"
#include "SoundEngine_Singleton.h"

namespace jm
{
    class TankExample : public Game2D
    {
    public:
        MyTank tank;

        MyBullet *bullet = nullptr;
        //TODO: allow multiple bullets
        //TODO: delete bullets when they go out of the screen

        //SoundEngine sound_engine;
        //SoundEngine_Singleton sound_engine;	// This is not supposed to happen

    public:
        TankExample()
            : Game2D("This is my digital canvas!", 1024, 768, false, 2)
        {
            auto & sound_engine = *SoundEngine_Singleton::getInstance();

            sound_engine.createSound("drumloop.wav", "background_music", true);
            sound_engine.createSound("truck_idle_off_02.wav", "tank_move", true);
            sound_engine.createSound("cannon1.wav", "cannon", false);
            sound_engine.createSound("missile.mp3", "missile", false);

            sound_engine.playSound("background_music");
        }

        ~TankExample()
        {
            if(bullet != nullptr) delete bullet;
        }

        void update() override
        {
            auto & sound_engine = *SoundEngine_Singleton::getInstance();

            // move tank
            bool is_moving = false;

            if (isKeyPressed(GLFW_KEY_LEFT)) {
                tank.moveLeft(getTimeStep());
                is_moving = true;
            }

            if (isKeyPressed(GLFW_KEY_RIGHT)) {
                tank.moveRight(getTimeStep());
                is_moving = true;
            }

            if (isKeyPressed(GLFW_KEY_UP)) {
                tank.moveUp(getTimeStep());
                is_moving = true;
            }

            if (isKeyPressed(GLFW_KEY_DOWN)) {
                tank.moveDown(getTimeStep());
                is_moving = true;
            }

            if(is_moving)
                sound_engine.playSound("tank_move");
            else
                sound_engine.stopSound("tank_move");

            // shoot a cannon ball
            if (isKeyPressedAndReleased(GLFW_KEY_SPACE))
            {
                if (bullet != nullptr) delete bullet;

                bullet = new MyBullet;
                bullet->center = tank.center;
                bullet->center.x += 0.2f;
                bullet->center.y += 0.1f;
                bullet->velocity = vec2(2.0f, 0.0f);

                sound_engine.stopSound("cannon");
                sound_engine.playSound("cannon");				
            }

            if (bullet != nullptr) bullet->update(getTimeStep());

            // rendering
            tank.draw();
            if (bullet != nullptr) bullet->draw();
        }
    };
}
```
SoundEngine.h ëŒ€ì‹  SoundEngine_Singleton.h ë¥¼ include í•œë‹¤.    
ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•  ìˆ˜ ì—†ê¸° ë•Œë¬¸ì— ì‚¬ìš©í•  ë•Œ ë§ˆë‹¤ SoundEngine_Singleton::getInstance() ë¡œ í¬ì¸í„°(ë ˆí¼ëŸ°ìŠ¤) ë¥¼ ë°›ì•„ì™€ì„œ ì‚¬ìš©í•œë‹¤.

#### ì‹±ê¸€í†¤ íŒ¨í„´ì˜ ì¥ì 
bullet ì´ ë‚ ì•„ê°€ëŠ” ë™ì•ˆ ì†Œë¦¬ë¥¼ ì¬ìƒì‹œì¼œì•¼ í•  ë•Œ í•´ë‹¹ ì½”ë“œëŠ” MyBullet ë‚´ë¶€ì—ì„œ êµ¬í˜„í•˜ê¸° ë•Œë¬¸ì— MyBullet ì— ì‚¬ìš´ë“œ ì—”ì§„ì˜ ì •ë³´ë¥¼ ì•Œë ¤ì£¼ê¸° ìœ„í•´ bullet ì„ ìƒì„±í•  ë•Œ ë§ˆë‹¤ ì‚¬ìš´ë“œ ì—”ì§„ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ íŒŒë¼ë¯¸í„°ë¡œ ë„˜ê²¨ì¤˜ì•¼ í•  ê²ƒì´ë‹¤.    
í•˜ì§€ë§Œ ê·¸ëŸ´ ê²½ìš°ì—ëŠ” ì‚¬ìš´ë“œ ì—”ì§„ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìˆ˜ë§ì€ ê³³ì— ë„˜ê²¨ì¤˜ì•¼ í•˜ê¸° ë•Œë¬¸ì— ë¶ˆí¸í•˜ê³  íŒŒë¼ë¯¸í„°ë¡œ ë„˜ê²¨ì£¼ëŠ” ë°©ì‹ì„ ì¼ì¼íˆ êµ¬í˜„í•˜ê¸°ê°€ í˜ë“¤ë‹¤.    
ì‹±ê¸€í†¤ íŒ¨í„´ì„ ì´ìš©í•´ ì´ë¥¼ í•´ê²°í•  ìˆ˜ ìˆë‹¤.
```cpp
#pragma once

#include "Game2D.h"
#include "SoundEngine_Singleton.h"

namespace jm
{
    class MyBullet
    {
    public:
        vec2 center = vec2(0.0f, 0.0f);
        vec2 velocity = vec2(0.0f, 0.0f);

        MyBullet()
        {
            SoundEngine_Singleton::getInstance()->playSound("missile");
        }

        ~MyBullet()
        {
            SoundEngine_Singleton::getInstance()->stopSound("missile");
        }

        void draw()
        {
            beginTransformation();
            translate(center);
            drawFilledRegularConvexPolygon(Colors::yellow, 0.02f, 8);
            drawWiredRegularConvexPolygon(Colors::gray, 0.02f, 8);
            endTransformation();
        }

        void update(const float& dt)
        {
            center += velocity * dt;
        }
    };
}
```
ì‹±ê¸€í†¤ íŒ¨í„´ì„ ì‚¬ìš©í•œ ì‚¬ìš´ë“œ ì—”ì§„ì˜ ì¸ìŠ¤í„´ìŠ¤ëŠ” static ìœ¼ë¡œ ë‹¨ í•˜ë‚˜ë§Œ ì¡´ì¬í•˜ê¸° ë•Œë¬¸ì— getInstance í•¨ìˆ˜ë¡œ ë°›ì•„ì™€ì„œ ì‚¬ìš©í•´ë„ í•­ìƒ ë™ì¼í•œ ì£¼ì†Œì˜ ì‚¬ìš´ë“œ ì—”ì§„ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì‰½ê²Œ ë°›ì•„ì™€ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

### ì£¼ì˜ì‚¬í•­
ì‹±ê¸€í†¤ íŒ¨í„´ì„ ì‚¬ìš©í•˜ì§€ ì•Šê³  SoundEngine í´ë˜ìŠ¤ì˜ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì—¬ëŸ¬ê°œ ìƒì„±í•´ì„œ ì‚¬ìš©í•˜ëŠ” ê²½ìš° (ex.TankExample í´ë˜ìŠ¤ ì´ì™¸ì˜ MyBullet í´ë˜ìŠ¤ì—ì„œ ë˜ ë‹¤ë¥¸ SoundEngine ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•˜ì—¬ ì‚¬ìš©í•˜ëŠ” ê²½ìš°) ëŠ” ì ˆëŒ€ ë¶ˆê°€ëŠ¥í•˜ë‹¤.    
ì™œëƒí•˜ë©´ ë³´í†µ ì‚¬ìš´ë“œ ì¹´ë“œëŠ” í•˜ë‚˜ì´ë¯€ë¡œ í•˜ë“œì›¨ì–´ë¥¼ ì œì–´í•˜ëŠ” ëª¨ë“ˆì„ ì—¬ëŸ¬ê°œ ì´ˆê¸°í™” í•˜ë©´ ì•ˆì¢‹ì€ ì¼, ì˜ˆì¸¡í•  ìˆ˜ ì—†ëŠ” ì¼ì´ ë°œìƒí•  ìœ„í—˜ì´ ìˆë‹¤. 
<pre>ë³¸ ë¸”ë¡œê·¸ëŠ” ê°œì¸ ê³µë¶€ ê¸°ë¡ì˜ ëª©ì ì„ ê°€ì§‘ë‹ˆë‹¤. í¬ìŠ¤íŠ¸ì˜ ë‚´ìš©ì€ ì–¸ì œë“ ì§€ ë°”ë€” ìˆ˜ ìˆìŠµë‹ˆë‹¤.</pre>{: .notice--info}