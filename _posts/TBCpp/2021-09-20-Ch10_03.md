---
title: "C++ Chapter10_3 ì§‘í•© ê´€ê³„ Association"
excerpt: "ì§‘í•© ê´€ê³„ Association"
categories:
  - Cpp
tags:
  - Cpp
last_modified_at: 2021-09-20
toc: true
toc_sticky: true
toc_label: "ëª©ì°¨ğŸ‘€"
---

<pre>ë³¸ í•„ê¸°ëŠ” ì¸í”„ëŸ°ì˜ í™ì •ëª¨ êµìˆ˜ë‹˜ì˜ ê°•ì˜ì¸ <b>í™ì •ëª¨ì˜ ë”°ë¼í•˜ë©° ë°°ìš°ëŠ” C++</b> ë¥¼ ë“£ê³  ì‘ì„±í•©ë‹ˆë‹¤.</pre>{: .notice--success}

### [êµ¬ì„± ê´€ê³„ Composition ì˜ ë¬¸ì œì ]
```cpp
// in main.cpp
#include <iostream>
#include <vector>
#include <string>
#include "Lecture.h"

int main()
{
    using namespace std;

    // local variable , í”„ë¡œê·¸ë¨ì´ ëë‚ ë•Œ ëª¨ë‘ ì‚¬ë¼ì§„ë‹¤.
    Student std1("Jack Jack", 0);
    Student std2("Dash", 1);
    Student std3("Violet", 2);
    Teacher teacher1("Prof. Hong");
    Teacher teacher2("Prof. Good");

    // Composition Relationship 
    Lecture lec1("Introduction to Computer Programming");
    lec1.assignTeacher(teacher1);
    lec1.registerStudent(std1);
    lec1.registerStudent(std2);
    lec1.registerStudent(std3);

    Lecture lec2("Computational Thinking");
    lec2.assignTeacher(teacher2);
    lec2.registerStudent(std1);

    // test
    {
        cout << lec1 << endl;
        cout << lec2 << endl;

        // event
        lec2.study();

        cout << lec1 << endl;
        cout << lec2 << endl;
    }

    return 0;
}

// ì¶œë ¥
Lecture name : Introduction to Computer Programming
Prof. Hong
Jack Jack 0
Dash 1
Violet 2

Lecture name : Computational Thinking
Prof. Good
Jack Jack 0

Computational Thinking Study

Lecture name : Introduction to Computer Programming
Prof. Hong
Jack Jack 0
Dash 1
Violet 2

Lecture name : Computational Thinking
Prof. Good
Jack Jack 1
```
* 2ê°œì˜ ê°•ì˜ì™€ 3ëª…ì˜ í•™ìƒê³¼ 2ëª…ì˜ ì„ ìƒì´ ì¡´ì¬í•  ë•Œ ê°ê°ì˜ ê°•ì˜ëŠ” í•™ìƒê³¼ ì„ ìƒì„ ë“±ë¡í•œë‹¤.
* lec1 ê³¼ lec2 ì— ë“±ë¡ëœ í•™ìƒë“¤ì˜ intelligence ë¥¼ ì¶œë ¥í•œë‹¤.
* lec2 ì— ë“±ë¡ëœ í•™ìƒì„ ëŒ€ìƒìœ¼ë¡œ `lec2.study();` ê³µë¶€ë¥¼ ì‹œí‚¨ë‹¤.
    * lec2 ì— ë“±ë¡ëœ í•™ìƒì˜ intelligence ê°€ ì¦ê°€í•œë‹¤.
* ê³µë¶€ê°€ ëë‚œ í›„ ë‹¤ì‹œ lec1 ê³¼ lec2 ì— ë“±ë¡ëœ í•™ìƒë“¤ì˜ intelligence ë¥¼ ì¶œë ¥í•œë‹¤.
* lec1 ê³¼ lec2 ì— ë™ì¼í•œ ì¸ë¬¼ì¸ Jack Jack ì„ ë“±ë¡í•˜ê³  `lec2.study();` ì„ í†µí•´ lec2 ì— ë“±ë¡ëœ Jack Jack ì˜ intelligence ë¥¼ ì¦ê°€ì‹œì¼°ì„ ë•Œ lec1 ì˜ Jack Jack ì˜ intelligence ëŠ” ì¦ê°€í•˜ì§€ ì•ŠëŠ”ë‹¤.
    * ì´ì²˜ëŸ¼ Composition ê´€ê³„ì—ì„œëŠ” ìƒìœ„ í´ë˜ìŠ¤ì˜ ê°ì²´ê°€ ê°€ì§€ëŠ” ì„œë¸Œ í´ë˜ìŠ¤ì˜ ê°ì²´ëŠ” ë‹¤ë¥¸ ê°ì²´ì™€ëŠ” ê³µìœ í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ë¶ˆí¸í•œ ì ì´ ìƒê¸´ë‹¤.
        * lec1 ê³¼ lec2 ë¥¼ ë™ê¸°í™”ì‹œí‚¤ëŠ” ë°©ë²•ì€ ìˆì§€ë§Œ ë¶ˆí¸í•˜ê³  ë¹„íš¨ìœ¨ì ì´ë‹¤.

<br>

> **ì§‘í•© ê´€ê³„ Association ì„ ì‚¬ìš©í•´ ë¶ˆí¸í•œ ì ì„ í•´ê²°í•œë‹¤.**

___
<br>

### [ì§‘í•© ê´€ê³„ Association]
#### ë©¤ë²„ Teacher í´ë˜ìŠ¤
```cpp
// in Teacher.h
#include <string>

class Teacher
{
private:
    std::string m_name;
    //TODO: more members like home address, salary, age, evaluation, etc. 

public:
    Teacher(const std::string &name_in = "No Name")
        : m_name(name_in)
    {}

    void setName(const std::string &name_in)
    {
        m_name = name_in;
    }

    std::string getName()
    {
        return m_name;
    }

    friend std::ostream& operator << (std::ostream &out, const Teacher &teacher)
    {
        out << teacher.m_name;
        return out;
    }
};
```

___
<br>

#### ë©¤ë²„ Student í´ë˜ìŠ¤
```cpp
// in Student.h
#include <iostream>
#include <string>

class Student
{
private:
    std::string m_name;
    int m_intel;	// intelligence;
    //TODO: add more members like address, phone, favorite food, habits, ...

public:
    Student(const std::string &name_in = "No Name", const int &intel_in = 0)
        : m_name(name_in), m_intel(intel_in)
    {}

    void setName(const std::string &name_in)
    {
        m_name = name_in;
    }

    void setIntel(const int &intel_in)
    {
        m_intel = intel_in;
    }

    int getIntel()
    {
        return m_intel;
    }

    friend std::ostream& operator << (std::ostream &out, const Student &student)
    {
        out << student.m_name << " " << student.m_intel;
        return out;
    }
};
```

#### ê´€ê³„ì˜ ì£¼ì²´ Lecture í´ë˜ìŠ¤
```cpp
// in Lecture.h
#include <vector>
#include "Student.h"
#include "Teacher.h"

class Lecture
{
private:
    std::string m_name;

    // Composition Relationship
    //Teacher teacher;			
    //std::vector<Student> students;	

    // Aggregation relationship
    Teacher *teacher = nullptr;	
    std::vector<Student*> students;	
public:
    Lecture(const std::string &name_in)
        : m_name(name_in)
    {}

    ~Lecture()
    {
        // do NOT delete teacher
        // do NOT delete students
    }

    // Composition Relationship
    /*void assignTeacher(const Teacher & const teacher_input)
    {
        teacher = teacher_input;
    }*/

    // Aggregation Relationship
    void assignTeacher(Teacher * const teacher_input)
    {
        teacher = teacher_input;
    }

    // Composition Relationship
    /*void registerStudent(const Student & const student_input)
    {
    	students.push_back(student_input);
    }*/

    // Aggregation Relationship
    void registerStudent(Student * const student_input)
    {
        students.push_back(student_input);
    }

    void study()
    {
        std::cout << m_name << " Study " << std::endl << std::endl;

        // Composition Relationship
        /*for (auto & element : students)	
            element.setIntel(element.getIntel() + 1);*/

        // Aggregation Relationship
        for (auto element : students)
            //(*element).setIntel((*element).getIntel() + 1);	
            element->setIntel(element->getIntel() + 1);
    }

    friend std::ostream & operator << (std::ostream & out, const Lecture & lecture)
    {
        out << "Lecture name : " << lecture.m_name << std::endl;
        
        // Composition Relationship
        /*out << lecture.teacher << std::endl;
        for (auto element : lecture.students)
            out << element << std::endl;*/

        // Aggregation Relationship
        out << *(lecture.teacher) << std::endl;
        for (auto element : lecture.students)
            out << *element << std::endl;

        return out;
    }
};
```
> ë©¤ë²„ ë°ì´í„° Composition VS Aggregation

* `Teacher teacher;`, `std::vector<Student> students;` **Composition ê´€ê³„**
    * Lecture ê°€ ì‚¬ë¼ì§€ë©´ teacher ì™€ students ê°€ ëª¨ë‘ ì‚¬ë¼ì§„ë‹¤.
    * students ê°€ ê°€ì§€ëŠ” Student ëŠ” address ê°€ ì•„ë‹Œ value ì´ë¯€ë¡œ ë³µì‚¬ë˜ì„œ vector ì— ì €ì¥ëœë‹¤. 
    * ë”°ë¼ì„œ ì™¸ë¶€ì—ì„œ ë“±ë¡í•¨ìˆ˜ì˜ ì¸ìˆ˜ë¡œ ë„˜ê²¨ì¤€ Student ì™€ vector ì˜ ì›ì†Œ Student ëŠ” ë‹¤ë¥¸ ê°ì²´ì´ë‹¤.
        * ì¦‰, lec1 , lec2 , main ì—ì„œì˜ std1 ì€ ëª¨ë‘ ë‹¤ë¥¸ ê°ì²´ì´ë¯€ë¡œ lec2 ì˜ study() í›„ì—ë„ lec1 ì˜ std1 ì˜ intel ì´ ì˜¬ë¼ê°€ì§€ ì•Šì•˜ë‹¤. 
* `Teacher *teacher = nullptr;`, `std::vector<Student*> students;` **Aggregation ê´€ê³„**
    * ìœ„ì˜ ë¬¸ì œì ì„ í•´ê²°í•˜ê¸° ìœ„í•´ Lecture ê°ì²´ê°€ ì™¸ë¶€ì—ì„œ ë“±ë¡í•¨ìˆ˜ì˜ ì¸ìˆ˜ë¡œ ë„˜ê²¨ì¤€ Student ì™€ Teacher ë“¤ì˜ ì£¼ì†Œë¥¼ ê°–ê²Œí•œë‹¤. (ë³µì‚¬X) 
        * ì£¼ì†Œë¥¼ ê°–ê¸°ìœ„í•´ teacher ì™€ students ëŠ” í¬ì¸í„°ë¥¼ ì €ì¥í•˜ë„ë¡ í•œë‹¤.
* `~Lecture() {~}`
    * Lecture ì˜ ì¸ìŠ¤í„´ìŠ¤ê°€ ì‚¬ë¼ì§€ë©´ Lecture ì˜ ë³€ìˆ˜ teacher, students ëŠ” ì‚¬ë¼ì§€ì§€ë§Œ ì´ í¬ì¸í„°ë“¤ì´ ê°€ë¥´í‚¤ë˜ ì¸ìŠ¤í„´ìŠ¤ë“¤ì€ ì™¸ë¶€ì—ì„œ ë„˜ê²¨ì¤€ ê°ì²´ì™€ ë™ì¼í•˜ê¸° ë•Œë¬¸ì— ì‚¬ë¼ì§€ì§€ ì•Šë„ë¡ í•´ì•¼í•œë‹¤.
        * ê·¸ë ‡ê¸° ë•Œë¬¸ì— ì†Œë©¸ìì—ì„œ teacher ì™€ students ê°€ ê°€ë¥´í‚¤ëŠ” ë©”ëª¨ë¦¬ë¥¼ delete í•˜ì§€ ì•Šë„ë¡ ì£¼ì˜í•´ì•¼ í•œë‹¤.

> í•¨ìˆ˜ assignTeacher Composition VS Aggregation

* `void assignTeacher(const Teacher & const teacher_input) {~}` **Composition ê´€ê³„**
    * Teacher ê°ì²´ë¥¼ ì €ì¥í•˜ê¸° ìœ„í•´ ë ˆí¼ëŸ°ìŠ¤ë¡œ ë°›ëŠ”ë‹¤.
* `void assignTeacher(Teacher * const teacher_input) {~}` **Aggregation ê´€ê³„**
    * Teacher ê°ì²´ì˜ ì£¼ì†Œë¥¼ ì €ì¥í•˜ê¸° ìœ„í•´ í¬ì¸í„°ë¡œ ë°›ëŠ”ë‹¤.
    
> í•¨ìˆ˜ registerStudent Composition VS Aggregation

* `void registerStudent(const Student & const student_input) {~}` **Composition ê´€ê³„**
    * `students.push_back(student_input);` students ê°€ &lt;Student> í˜•ì˜ ë°ì´í„°ë¥¼ ì €ì¥í•˜ê¸° ë•Œë¬¸ì— student_input ì˜ ê°’ì„ ë³µì‚¬í•˜ì—¬ ì €ì¥í•œë‹¤. ë”°ë¼ì„œ student_input ê³¼ ë‹¤ë¥¸ Student ê°ì²´ê°€ ì €ì¥ëœë‹¤.
* `void registerStudent(Student * const student_input) {~}` **Aggregation ê´€ê³„**
    * í¬ì¸í„°ë¡œ ì™¸ë¶€ì—ì„œ Student ê°ì²´ì˜ ì£¼ì†Œë¥¼ ë°›ëŠ”ë‹¤.
    * `students.push_back(student_input);` students ê°€ &lt;Student*> í˜•ì˜ ë°ì´í„°ë¥¼ ì €ì¥í•˜ê¸° ë•Œë¬¸ì— ì™¸ë¶€ì—ì„œ ë°›ì€ Student ê°ì²´ì˜ ì£¼ì†Œë¥¼ students ì˜ ì›ì†Œë¡œ ì €ì¥í•œë‹¤. ë”°ë¼ì„œ ì™¸ë¶€ì—ì„œ ì „ë‹¬í•œ Student ê°ì²´ë¥¼ ê°€ë¥´í‚¤ëŠ” í¬ì¸í„° ë³€ìˆ˜ë¥¼ ê°€ì§„ì…ˆì´ë‹¤.

> í•¨ìˆ˜ study Composition VS Aggregation

* `void study() {~}`
    * `for (auto & element : students) {~}` **Composition ê´€ê³„**
        * `for (auto element : students)` ëŠ” students ì˜ ì›ì†Œë¥¼ ë³µì‚¬í•´ì„œ element ë¡œ ê°€ì ¸ì˜¤ê¸° ë•Œë¬¸ì— students ì˜ ì›ì†Œì˜ ê°’ì„ ë³€ê²½í•  ìˆ˜ ì—†ë‹¤.
            * ë”°ë¼ì„œ ë ˆí¼ëŸ°ìŠ¤ë¡œ students ì˜ ì›ì†Œë¥¼ ê°€ì ¸ì˜¨ë‹¤.
    * `for (auto element : students) {~}` **Aggregation ê´€ê³„**
        * students ì˜ ì›ì†ŒëŠ” Student ê°ì²´ë¥¼ ê°€ë¥´í‚¤ëŠ” í¬ì¸í„°ì´ë¯€ë¡œ ë³µì‚¬ëœ element ë¡œë„ students ì˜ ì›ì†Œê°€ ê°€ë¥´í‚¤ëŠ” Student ê°ì²´ì— ì ‘ê·¼í•  ìˆ˜ ìˆë‹¤.
        * `(*element).setIntel((*element).getIntel() + 1);` ê³¼ `element->setIntel(element->getIntel() + 1);` ì€ ê°™ì€ í‘œí˜„ì´ë‹¤.

> << ì—°ì‚°ì ì˜¤ë²„ë¡œë”© í•¨ìˆ˜

* students ê°€ ì €ì¥í•˜ëŠ” ì›ì†Œì˜ ë°ì´í„°í˜•ì— ë”°ë¥¸ ì°¨ì´ë§Œì´ ì¡´ì¬í•œë‹¤.

___
<br>

#### ì‚¬ìš© ì˜ˆ
```cpp
// in main.cpp
#include <iostream>
#include <vector>
#include <string>
#include "Lecture.h"

int main()
{
    using namespace std;

    // local variable
    Student std1("Jack Jack", 0);
    Student std2("Dash", 1);
    Student std3("Violet", 2);
    Teacher teacher1("Prof. Hong");
    Teacher teacher2("Prof. Good");

    // Pointer Dynamic Allocation instead local variable (if necessary)
    /*Student *std1 = new Student("Jack Jack", 0);	
    Student *std2 = new Student("Dash", 1);
    Student *std3 = new Student("Violet", 2);
    Teacher *teacher1 = new Teacher("Prof. Hong");
    Teacher *teacher2 = new Teacher("Prof. Good");*/

    // Composition Relationship (without &)
    // Aggregation Relationship (with &)
    Lecture lec1("Introduction to Computer Programming");
    lec1.assignTeacher(&teacher1);
    lec1.registerStudent(&std1);
    lec1.registerStudent(&std2);
    lec1.registerStudent(&std3);

    Lecture lec2("Computational Thinking");
    lec2.assignTeacher(&teacher2);
    lec2.registerStudent(&std1);

    // test
    {
        cout << lec1 << endl;
        cout << lec2 << endl;

        // event
        lec2.study();

        cout << lec1 << endl;
        cout << lec2 << endl;
    }

    // delete memory (if necessary)
    /*delete std1;
    delete std2;
    delete std3;
    delete teacher1;
    delete teacher2;*/

    return 0;
}

// ì¶œë ¥
Lecture name : Introduction to Computer Programming
Prof. Hong
Jack Jack 0
Dash 1
Violet 2

Lecture name : Computational Thinking
Prof. Good
Jack Jack 0

Computational Thinking Study

Lecture name : Introduction to Computer Programming
Prof. Hong
Jack Jack 1
Dash 1
Violet 2

Lecture name : Computational Thinking
Prof. Good
Jack Jack 1
```
* Local Variable
    * í”„ë¡œê·¸ë¨ì´ ëë‚  ë•Œ ëª¨ë‘ ì‚¬ë¼ì§„ë‹¤.
* Pointer Dynamic Allocation
    * í¬ì¸í„° ë™ì í• ë‹¹ , ë‹¤ë¥¸ ê³³ì—ì„œë„ ì‚¬ìš©í•  ë•Œ ì‚¬ìš©í•œë‹¤. 
        * ì´í›„ì— ë°˜ë“œì‹œ delete í•´ì¤˜ì•¼í•œë‹¤.
	* Student , Teacher ë³€ìˆ˜ ìì²´ê°€ í¬ì¸í„° ì´ë¯€ë¡œ Lecture ì˜ í•¨ìˆ˜ë“¤ì„ í˜¸ì¶œí•  ë•Œ argument ì˜ & ëŠ” ë¹¼ì¤€ë‹¤.
* Composition Relationship ì˜ˆì‹œì™€ëŠ” ë‹¤ë¥´ê²Œ `lec2.study();` ê°€ ìˆ˜í–‰ë˜ê³  ë‚œ ë’¤ì˜ lec1 ê³¼ lec2 ì˜ std1 ì˜ intelligence ëŠ” ë™ì¼í•˜ê²Œ ì¦ê°€í•˜ëŠ” ê²ƒì„ ë³¼ ìˆ˜ ìˆë‹¤.
    * ì¦‰, lec1 , lec2 , main ì—ì„œì˜ std1 ì€ ë™ì¼í•œ ê°ì²´ì„ì„ ì•Œ ìˆ˜ ìˆë‹¤.


<pre>ë³¸ ë¸”ë¡œê·¸ëŠ” ê°œì¸ ê³µë¶€ ê¸°ë¡ì˜ ëª©ì ì„ ê°€ì§‘ë‹ˆë‹¤. í¬ìŠ¤íŠ¸ì˜ ë‚´ìš©ì€ ì–¸ì œë“ ì§€ ë°”ë€” ìˆ˜ ìˆìŠµë‹ˆë‹¤.</pre>{: .notice--info}